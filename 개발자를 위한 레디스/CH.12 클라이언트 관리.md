# CH.12 클라이언트 관리

## 클라이언트 핸들링
- 일반적으로는 사용자 연결을 받기 위해 TCP 포트를 사용하지만, 설정 파일에서 `unixsocket` 및 `unixsocketperm` 매개변수를 설정하면 원하는 경로에 소켓파일을 생성하고 해당 파일의 권한을 지정할 수 있다.
```shell

unixsocket /tmp/redis.sock
unixsocketperm 777
```
- 이후에는 클라이언트가 해당 유닉스 소켓파일의 경로를 사용해 레디스 서버에 연결할 수 있다.
```shell

redis-cli -s /tmp/redis.sock
```
- 레디스는 멀티플렉싱(Multiplexing) 방식을 사용하며, 이로 인해 하나의 통신 채널을 통해 여러 데이터 스트림을 전송할 수 있다.
- 하나의 스레드에서 여러 소켓을 감시하고, 소켓 이벤트가 발생하는지 지속적으로 확인할 수 있기 때문에 효율적인 다중 클라이언트 지원을 가능하게 하고, 많은 클라이언트 요청을 동시에 처리하는 데 블로킹 문제를 피할 수 있다.
- 논블로킹 I/O(Non-blocking I/O)를 활용해 I/O 작업이 완료될 때까지 대기하지 않고 다른 작업을 처리할 수 있어서, 클라이언트 요청을 비동기적으로 처리하고 다수의 클라이언트 요청을 동시에 처리할 수 있다.
- 클라이언트 소켓에서 새로운 데이터가 도착하면 읽기 가능한 파일 이벤트를 생성하며, 레디스는 이를 이용해 클라이언트에서 전송한 쿼리를 수집하고 처리한다.
- 클라이언트가 초기화되면 레디스는 `maxclients` 설정값과 비교해 현재의 클라이언트 수가 `maxclients` 값에 도달했는지 확인한다.
- 이 값을 초과하면 새로운 클라이언트의 접속을 거부한다.
### 클라이언트 버퍼 제한
- 레디스는 클라이언트에 반환할 데이터를 임시로 저장하기 위해 각 클라이언트마다 클라이언트 출력 버퍼(client output buffer)를 생성한다.
- 연결된 클라이언트가 1,000개라면 1,000개의 출력버퍼를 생성한다.
- 출력버퍼는 레디스가 반환할 데이터 양에 따라 가변된 길이를 갖게 되지만 만약 클라이언트가 데이터를 처리하지 못하고 계속해서 서버에 요청을 보내면 서버의 출력 버퍼 크기가 계속해서 증가하며, 이로 인해 메모리 사용량이 늘어난다.
- 특히 pub/sub 클라이언트에서 발행자가 메시지를 발행하면 해당 메시지는 모든 구독자에게 전달한다.
- 일반적으로 pub/sub 연결의 경우 발행자가 보낸 새로운 메시지를 구독자가 처리하는 속도가 충분하지 않은 상황이 발생하는 경우가 많다.
- 따라서 레디스는 출력버퍼 크기에 대한 제한을 둬서, 버퍼크기가 일정수준 이상으로 증가할 경우 클라이언트 연결을 종료하게 된다.
- 레디스에서는 일반 클라이언트와 pub/sub 클라이언트 그리고 복제본을 위한 출력버퍼 크기가 모두 다르게 적용된다.
- 기본적으로 일반 클라이언트는 출력 버퍼 크기 제한이 0으로 설정돼 있다.
- 하나의 커맨드를 보내고 다음 커맨드를 보내기 전에 응답을 받기를 기다리기 때문에 연결을 닫아버리는 것은 예상하지 못한 동작방식일 수 있기 때문이다.
- Pub/sub 클라이언트의 경우 기본 하드제한은 32MB이며, 소프트 제한은 60초당 8MB이다.
- 이는 pub/sub 클라이언트가 빠르게 처리되는 메시지들을 처리하기 위해 더 많은 메모리 공간이 필요하기 때문이다.
- 복제본을 위한 출력버퍼 크기제한은 기본이 하드제한은 256MB, 소프트제한은 60초 당 64MB이다.
- 이는 복제본이 마스터 서버로부터 대량의 데이터를 받아들이는 경우가 많아, 더 큰 출력 버퍼가 필요하기 때문이다.
- 이를 변경하기 위해서는 설정값을 변경하거나 `CONFIG SET`으로 변경할 수 있다.
```shell

CONFIG SET client-output-buffer-limit <class> <hard-limit> <soft-limit> <soft-limit-duration>
```
- <class>는 normal, slave(replica), pubsub 중 하나다.
- normal은 일반 레디스 클라이언트를 나타내며, slave와 replica는 레디스 복제본 클라이언트를, pubsub 클래스는 pub/sub 클라이언트를 나타낸다.
- 클라이언트 쿼리버퍼는 클라이언트에서 받은 커맨드를 레디스에서 잠시 보관하는 내부버퍼의 역할을 한다.
### 클라이언트 이빅션
- 클라이언트 연결이 메모리를 과다 사용해 OOM(out of Memory)이 발생하거나 데이터 이빅션을 유발할 수도 있다.
- 레디스 7.0부터는 `maxmemory-clients` 설정값을 사용해 모든 클라이언트 연결(pub/sub 및 일반 클라이언트 모두)이 사용하는 누적메모리 양을 제한할 수 있게 됐다.
- 임계치에 도달하면 레디스는 서버에서 클라이언트 연결을 해제해 메모리를 확보한다.
- 서버는 가장 많은 메모리를 사용하는 연결부터 해제하려고 시도하며, 이 기능을 클라이언트 이빅션(client eviction)이라고 한다.
- `maxmemory-clients` 설정값은 레디스에 연결된 모든 클라이언트의 최대 총 메모리 사용량을 정의한다.
- 기본 설정값은 0으로, 이는 해당기능이 기본적으로 비활성화돼 있다는 것을 의미한다.
- 대규모 트래픽 환경에서는 클라이언트 연결에 사용되는 메모리 양을 제어하기 위해 5%나 10%와 같은 값을 설정하는 것이 권장된다.
- 특정 클라이언트 연결을 클라이언트 이빅션 기능에서 제외시킬 수도 있다.
- 레디스 서버를 주기적으로 모니터링하고 알림을 보내는 애플리케이션의 경우, 해당 클라이언트 연결은 이빅션의 영향을 받지 않도록 설정하는 것이 좋다.
```shell

> CLIENT NO-EVICT on
OK
```
### Timeout과 TCP Keepalive
- 레디스 서버에 클라이언트가 연결되면, 장기간 동안 커맨드를 수행하지 않더라도 연결은 계속 유지된다.
- 특정 시점에서 활동이 없는 클라이언트를 정리하려면 타임아웃 설정을 사용해 유휴연결을 해제할 수 있다.
```shell

> CONFIG SET timeout 600
OK
```
- `tcp-keepalive`는 연결된 클라이언트에게 주기적으로 `TCP ACK`를 보내고, 클라이언트로부터 응답이 없는 경우에 연결을 끊는 설정이다.
- 이 설정은 타임아웃과 달리 클라이언트가 활동이 없을 때 즉시 연결을 끊는 것이 아니라, 실제로 클라이언트가 정상적으로 응답할 수 있는 상태인지를 우선적으로 확인한 다음 응답하지 않을 때에만 연결을 끊는 방식으로 동작한다.
- 기본적으로 이 값이 300초로 설정돼 있어서, 서버는 연결된 클라이언트에게 5분마다 한 번씩 `TCP ACK`를 보낸다.
## 파이프라이닝
- 레디스 서버와 클라이언트는 네트워크를 통해 연결돼 있으며, 요청과 응답 사이의 왕복시간(RTT, Round Trip Time)은 성능에 큰 영향을 끼친다.
- 왕복시간이 250ms인 경우 레디스 서버가 초당 10만개의 요청을 처리할 수 있더라도 네트워크 통신에 소요되는 시간 때문에 초당 최대 4개의 요청만을 처리할 수 있다.
- 네트워크 통신 소요시간을 줄임으로써 레디스의 성능을 크게 향상시킬 수 있다.
- 레디스에서 파이프라이닝은 클라이언트가 연속적으로 여러 개의 커맨드를 레디스 서버에 보낼 수 있도록 하는 기능이다.
```text
    Client                  Server
     |                       |
     | 요청 1 (⇒)             |
     |  ╲                    |
     |   ╲ 요청 시작           |
     |    ╲                  |
     |     ┗━━━━━━━━━━━▶  서버 수신/처리
     |     ◀━━━━━━━━━━━┛  응답 전송
     |    ╱                  |
     |   ╱ 응답 1 도착         |
     |  ╱                    |
     | 요청 2 (⇒)             |
     |  ╲                    |
     |   ╲ 요청 시작           |
     |    ╲                  |
     |     ┗━━━━━━━━━━━▶  서버 수신/처리
     |     ◀━━━━━━━━━━━┛  응답 전송
     |    ╱                  |
     |   ╱ 응답 2 도착         |
     |  ╱                    |
     | 요청 3 (⇒)             |
     |  ╲                    |
     |   ╲ 요청 시작           |
     |    ╲                  |
     |     ┗━━━━━━━━━━━▶  서버 수신/처리
     |     ◀━━━━━━━━━━━┛  응답 전송
     |    ╱                  |
     |   ╱ 응답 3 도착         |
     |  ╱                    |
     ↓                       ↓
```
```text
Client                  Server
         |                       |
         | 요청 1 (⇒)             |
         | ━━━━━━━━━━━━━━━▶ 요청 도착
         | 요청 2 (⇒)             |
         | ━━━━━━━━━━━━━━━▶ 요청 도착
         | 요청 3 (⇒)             |
         | ━━━━━━━━━━━━━━━▶ 요청 도착
         | 요청 4 (⇒)             |
         | ━━━━━━━━━━━━━━━▶ 요청 도착
         |                       |
         |                       |  (서버 처리 중...)
         |                       |
         |                       |
         | ━━━━━━━━━━━━━━━◀ 응답 1 전송
         | ━━━━━━━━━━━━━━━◀ 응답 2 전송
         | ━━━━━━━━━━━━━━━◀ 응답 3 전송
         | ━━━━━━━━━━━━━━━◀ 응답 4 전송
         | 응답 1~4 (⇐) 도착       |
         |                       |
         ↓                       ↓
```
- 다음과 같이 레디스 서버에 줄바꿈을 이용해 동시에 실행할 여러 개의 커맨드를 한 번에 보내면 된다.
```shell

$ (printf "PING\r\nPING\r\PING\r\n"; sleep 1) | nc localhost 6379
+PONG
+PONG
+PONG
```
- 레디스 서버가 클라이언트에 응답하기 위해 소켓 I/O를 수행할 때 운영체제 커널 영역의 read(), write() 시스템 콜을 호출하는 과정에서 발생하는 레이턴시(latency) 증가가 레디스 서버에서 데이터를 찾고 반환하는 과정보다 크다.
- 파이프라이닝을 사용하면 여러 명령이 단일 read() 시스템 콜로 읽혀지고 여러 응답이 단일 write() 시스템 호출로 전달되기 때문에 시스템 콜을 줄일 수 있어 처리랑을 줄일 수 있다.
## 클라이언트 사이드 캐싱