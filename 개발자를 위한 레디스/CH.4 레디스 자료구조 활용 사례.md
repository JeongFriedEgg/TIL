# CH.4 레디스 자료구조 활용 사례
- 레디스 자료 구조에 내장된 함수를 이용해 원하는 기능을 사용하면 데이터를 애플리케이션의 메모리 영역으로 가져간 뒤 가공하는 데에 걸리는 시간을 줄일 수 있다.
## sorted set을 이용한 실시간 리더보드
- 경쟁자들의 순위와 현재 점수를 보여주는 순위표.
- 절대적 리더보드(absoute leaderborad)는 서비스의 모든 유저를 정렬시켜 상위권의 목록만을 표시하는 반면 상대적 리더보드는 사용자마다 다른 데이터를 보여준다.
- 상대적 리더보드는 사용자의 스코어를 기반으로 그들을 다른 사용자와 비교해 순위를 결정하는 형태의 리더보드다.
- 리더보드는 실시간으로 반영돼야 하는 데이터다. 유저의 스코어가 100에서 110으로 변경되면 이 데이터는 실시간으로 계산돼 리더보드에서 자신의 순위가 상승한 것을 바로 확인할 수 있어야 한다.
- 레디스의 sorted set에서 데이터는 저장될 때부터 정렬돼 들어간다. 만약 유저의 스코어를 sorted set의 가중치로 설정한다면 스코어 순으로 유저가 정렬되기 때문에 리더보드의 데이터를 읽어오기 위해 매번 데이터를 정렬할 필요가 없다.
```shell

> ZADD daily-score: 220817 28 palyer: 286
(integer) 1

> ZADD daily-score:220817 400 palyer:234
(integer) 1

> ZADD daily-score:220817 45 player:101
(integer) 1

> ZADD daily-score:220817 357 player:24
(integer) 1

> ZADD daily-score:220817 199 player:143
(integer) 1
```
- 순서 없이 데이터를 저장하더라도 sorted set에는 데이터가 스코어 순으로 정렬돼 저장된다.
```shell

> ZRANGE daily-score:220817 0 -1 withscores
1) "palyer: 286"
2) "28"
3) "player:101"
4) "45"
5) "player:143"
6) "199"
7) "player:24"
8) "357"
9) "palyer: 234"
10) "480"
```
- 만약 게임의 첫 화면으로 오늘의 상위 스코어 세 명의 유저만 출력하고 싶다면 다음과 같이 ZREVRANGE 커맨드를 사용할 수 있다.
```shell

> ZREVRANGE daily-score: 220817 0 2 withscores
1) "palyer:234"
2) "400"
3) "player:24"
4) "357"
5) "player:143"
6) "199"
```
#### 데이터 업데이트
```shell

ZADD daily-score:220817 200 player: 286
```
- sorted set은 기본적으로 set이기 때문에 데이터는 중복으로 저장되지 않으며, 같은 아이템을 저장하고자 할 때 스코어가 다르면 기존 데이터의 스코어만 신규 입력한 스코어로 업데이트된다.
- 직접 스코어의 값을 지정해서 변경하지 않고도 ZINCRBY 커맨드를 이용해서 sorted set 내의 스코어를 증감시킬 수 있다.
```shell

ZINCRBY daily-score:220817 100 player: 24
```
- 기존 스코어가 357이었던 아이템 player:24의 스코어를 100 중가시키면 아이템은 457로 변경되며 재정렬된다.
- 관계형 데이터베이스만 이용해 실시간 차트 서비스를 구현하는 것은 까다로운 작업이다. 모든 유저의 변경 데이터는 실시간으로 업데이트돼야 하며, 점수별로 데이터를 정렬해서 가져오는 작업 자체가 관계형 데이터베이스에 상당한 부하를 줄 수 있기 때문이다.
#### 랭킹 합산
- 관계형 데이터베이스에서 이런 주간 누적 랭킹을 구현하려면 하나의 테이블에서 일자에 해당하는 데이터를 모두 가져온 뒤 선수별로 합치고, 이를 다시 소팅하는 작업을 진행해야 하지만, 레디스에서는 ZUNIONSTORE 커맨드를 사용해 간단하게 구현할 수 있다.
- ZUIONSTORE 커맨드는 지정한 키에 연결된 각 아이템의 스코어를 합산하는 커맨드다. 따라서 해당하는 일자의 키를 지정하기만 한다면 손쉽게 주간 리더보드 데이터를 얻을 수 있다.
- ZUIONSTORE는 <생성할 키 이름><합산할 키 개수><합산할 키>...와 같이 사용할 수 있으며, 22년 8월 15일부터 17일까지의 데이터를 합산하고 싶다면 다음과 같이 사용하자.
```shell

> ZUNIONSTORE weekly-score:2208-3 3 daily-score:220815 daily-score: 220816 daily-score: 220817
(integer) 4
```
```shell

> ZREVRANGE weekly-score:2208-03 0 -1 withscores
1) "player:24"
2) "650"
3) "player:234"
4) "650"
5) "player:286"
6) "200"
7) "player:101"
8) "150"
```
- ZUIONSTORE를 이용해 데이터를 합칠 때 스코어에 가중치를 줄 수도 있다. 만약 8월 16일에 스코어 두 배 이벤트가 있었다면 8월 16일 데이터에만 가중치를 두 배로 늘려 계산할 수 있다.
```shell

> ZUNIONSTORE weekly-score:2208-03 3 daily-score: 220815 daily-score:220816 daily-score: 220817 weights 1 2 1
(integer) 4
```
- WEIGHTS 옵션을 이용해 가중치를 줄 수 있으며, 위의 예제에서는 15일, 16일, 17일에 각각 1,2, 1을 곱한 값으로 합산된 랭킹을 구할 수 있다.
```shell

> zrevrange weekly-score:2208-03 0 -1 withscores
1) "player: 234"
2) "1050"
3) "player:24"
4) "1000"
5) "player: 286"
6)"400"
7) "player:101"
8) "150"
```
## sorted set을 이용한 최근 검색 기록
- 최근 검색 기록의 요구 사항
  - 유저별로 다른 키워드 노출
  - 검색 내역은 중복 제거
  - 가장 최근 검색한 5개의 키워드만 사용자에게 노출
```
SELECT * FROM keyword WHERE user_id = 123 ORDER BY reg_date DESC LIMIT 5;
```
- 테이블에 데이터를 저장할 때에는 기존에 사용자가 같은 키워드를 검색했었는지 확인한 뒤 업데이트해주는 작업을 추가해야 하며, 테이블에 데이터가 무기한으로 쌓이는 것을 방지하기 위해 주기적으로 배치 작업을 돌려 오래된 검색 기록은 삭제하는 작업이 필요할 수 있다.
- Sorted set은 set이기 때문에 저장될 때부터 중복을 허용하지 않으며, 스코어로 시간을 사용한다면 검색 기록으로 정렬될 수 있다.
- ID가 123인 유저가 2022년 11월 6일 14시 35 분 01초에 코듀로이라는 키워드를 검색했다면 데이터는 다음과 같이 저장된다.
```shell

> ZADD search-keyword:123 20221106143501 코듀로이
(integer) 1
```
- ZREVRANGE 커맨드를 사용해 가장 최근에 검색한 순서대로 데이터를 가져올 수 있으며, 이때 인덱스를 지정해 최근 5개의 데이터만 조회할 수 있다.
```shell

> ZREVRANGE search-keyword:123 0 4 withscores
기모후드
20221106152734
코듀로이
20221106143501
반지갑
20221105221002
에나멜
20221105220954
실버
20221105220913
```
- Sorted set을 이용해 데이터를 저장하기 때문에 같은 키워드를 다시 검색했을 때에도 별다른 중복 체크를 진행하지 않아도 된다. 각 아이템은 중복되지 않게 저장되기 때문에 같은 아이템의 데이터를 입력한다면 자동으로 스코어만 업데이트돼 재정렬 된다.

- 데이터는 시간 순으로 정렬되기 때문에 가장 오래된 데이터를 지우기 위해서는 데이터가 6개째 저장됐을 때 가장 오래된 데이터인 0번 인덱스의 데이터를 삭제하면 된다. 하지만 매번 데이터를 저장할 때 아이템의 개수를 확인해야 하는 번거로움이 존재한다.
- 이때 sorted set의 음수 인덱스를 사용해서 데이터를 삭제한다면 위와 같은 번거로운 작업을 줄일 수 있다.
- 데이터가 6개 저장됐을 때 가장 오래전 저장된 데이터는 일반 인덱스로 0, 음수 인덱스로 -6이 된다.
- 항상 ZADD로 데이터를 저장할 때마다 음수 인덱스 -6번째를 삭제하는 로직을 추가하면 유저별 아이템의 개수를 확인하지 않더라도 5개 이상의 데이터가 저장되지 않도록 강제할 수 있다.
```shell

> ZADD search-keyword 20221106165302 버킷햇
1
> ZREMRANGEBYRANK search-keyword -6 -6
1
```
- ZREMRANGEBYRANK key start stop 커맨드를 이용하면 인덱스의 범위로 아이템을 삭제할 수 있으며, 따라서 정확히 -6번째 인덱스의 데이터만 지우기 위해서는 위와 같이 -6부터 -6까지 지정해서 처리할 수 있다.
## sorted set을 이용한 태그 기능
- 관계형 데이터베이스에서 태그 기능을 사용하려면 적어도 2개의 테이블이 추가돼야 한다. 첫 번째로는 태그 테이블, 두 번째로는 태그-게시물 테이블이다.
```text
post:47:tags -> IT REDIS DataStore
post:22:tags -> IT Python
post:53:tags -> DataStore IT MySQL
```
```shell

> SADD post:47:tags IT REDIS DataStore
3
> SADD post:22: tags IT python
2
```
- 데이터를 저장할 때에 포스트를 기준으로 하는 set 그리고 태그를 기준으로 하는 set에 각각 데이터를 넣어준다면 그 기능을 쉽게 구현할 수 있다.
```shell

> SADD post:53:tags DataStore IT MySQL
3
> SADD tag:DataStore:posts 53
1
> SADD tag: IT:posts 53
1
> SADD tag:MySQL:posts 53
1
```
```text
tag:IT:posts -> 47 22 53
tag:REDIS:posts -> 47
tag:MySQL:posts -> 53
tag:DataStore:posts -> 47 53
tag:Python:posts -> 22
```
- SMEMBERS 커맨드를 이용하면 특정 태그를 갖고 있는 포스트를 쉽게 확인할 수 있다.
```shell
> SMEMBERS tag:IT:posts
1) "22"
2) "47"
3) "53"
```
- SINTER 커맨드를 이용하면 특정 set의 교집합을 확인할 수 있다. 만약 IT와 Datastore 태그를 모두 포함하는 게시물을 확인하고 싶으면 다음과 같이 SINTER 커맨드를 사용할 수 있다.
```shell

> SINTER tag:IT:posts tag:DataStore:posts
1) "47"
2) "53"
```
- 관계형 데이터베이스에서 group by - having 절을 사용하면 검색하는 테이블의 크기에 따라 데이터베이스 자체에 부하를 발생시킬 수 있다.
```shell

SELECT post_id FROM tag_post WHERE tag_ id IN (1,3) GROUP BY post_id HAVING COUNT (tag_id) <= 2;
```
## 랜덤 데이터 추출
- 게임에서 랜덤으로 게임 유저를 매핑하거나 이벤트에 응모한 유저를 랜덤으로 추출하거나 가챠에서 랜덤으로 아이템을 뽑는 등의 로직을 구현하는 것을 가정해보자.
- 관계형 데이터베이스에서 랜덤 데이터 추출을 사용할 때에는 ORDER BY RAND() 함수를 많이 사용한다. 이 함수는 쿼리의 결값을 랜덤하게 정렬하지만, 조건절에 맞는 모든 행을 읽은 뒤, 임시 테이블에 넣어 정렬한 다음 랜덤으로 limit에 해당할 때까지 데이터를 추출한다.
- RANDOMKEY 커맨드는 레디스에 저장된 전체 키 중 하나를 무작위로 반환한다.
- HRANDFIELD, SRANDMEMBER, ZRANDMEMBER는 각각 hash, set, sorted set에 저장된 아이템 중 랜덤한 아이템을 추출할 수 있다.
```shell

> HRANDFIELD user:hash
"Id:4615"
> HRANDFILED user:hash 1 WITHVALUES
1) "Id:4615"
2) "Jinnji"
```
- HRANDFIELD 커맨드를 사용하면 지정한 hash 내에서 임의로 선택된 하나의 아이템을 추출할 수 있다.
- 이때 COUNT 옵션을 이용하면 원하는 개수만큼 랜덤 아이템이 반환되며, WITHVALUES 옵션을 사용하면 필드에 연결된 값도 함께 반환할 수 있다.
- 이때 COUNT 옵션을 양수로 설정하면 중복되지 않는 랜덤 데이터가 반환되고, 음수로 설정하면 데이터가 중복해서 반환될 수 있다.
```shell

> HRANDFIELD user:hash 2
1) "Id:4615"
2) "Id:134"
> HRANDFIELD user:hash -2
1) "Id:134"
2) "Id:134"
```
## 레디스에서의 다양한 카운팅 방법
- 단순히 아이템의 개수를 파악해야 하는 경우도 있고, 어떤 아이템이 저장됐는지 함께 파악해야 하는 경우도 있다. 때로는 약간의 오차를 허용하면서 매우 큰 데이터셋을 빠르게 처리하고자 할 때도 있다.
### 좋아요 처리하기
- 실시간 트래픽이 굉장히 많은 사이트라면 하나의 뉴스 댓글에 좋아요가 눌리는 일은 1초에 몇만 개 이상 발생할 수 있으며, 좋아요를 누를 때마다 관계형 데이터베이스 테이블의 특정 행에서 좋아요 개수 데이터를 증가시키는 일은 데이터베이스에 직접적인 영향을 끼칠 수 있다.
- 하나의 유저는 같은 댓글에 한 번씩만 좋아요를 누를 수 있어야 하기 때문에 단순히 좋아요의 개수를 파악하는 것이 아닌, 어떤 유저가 어떤 댓글에 좋아요를 눌렀는지의 데이터 또한 처리할 수 있어야 한다.
```text
comment-like:12554 -> 345 25 967
comment-like:19967 -> 508 86 167 816
```
- 댓글 id를 기준으로 set을 생성한 뒤, 좋아요를 누른 유저의 id를 Set에 저장하면 중복 없이 데이터를 저장할 수 있다.
- 댓글 id 12554에 좋아요를 누른 유저는 345, 25, 967이다.
```shell

> SADD comment-like:12554 967
(integer) 1
```
- 각 댓글별로 좋아요를 누른 수는 SCARD 커맨드로 확인할 수 있다.
```shell

> SCARD comment-like:12554
(integer) 3
```
### 읽지 않은 메시지 수 카운팅하기
- 채팅 메시지가 도착할 때마다 바로 관계형 데이터베이스를 업데이트하는 대신 데이터를 레디스와 같은 인메모리 데이터베이스에 일시적으로 저장한 뒤 필요한 시점에 한꺼번에 업데이트하는 방식을 사용해서 관계형 데이터베이스의 부하를 최소화하고 성능을 향상시키고자 한다.
- 채팅의 내용을 확인하거나 중복된 데이터를 고려할 필요 없이 단순히 채널에 새로 추가된 메시지의 개수를 확인하면 된다. 따라서 사용자의 ID를 키로 사용하고, 채널의 ID를 아이템의 키로 활용해 숫자 형태의 메시지 카운트 를 관리하는 방법을 고려할 수 있다.
```text
user:123 -> channel:4234 - 3
            channel:3135 - 27
            channel:1239 - 128
            
user:234 -> channel:1123 - 223
            channel:4234 - 0
            
user:345 -> channel:4339 - 2
            channel:1239 - 42
            channel:3299 - 3
            channel:15644 - 150
            channel:342 - 7
```
- ID가 234인 사용자가 4234 채널에서 새로운 메시지를 수신했다면 다음과 같은 명령어를 사용할 수 있다.
```shell

> HINCRBY user: 234 channel:4234 1
(integer) 1
```
- 만약 누군가가 이미 전송한 메시지를 삭제했다면 HINCRBY 명령을 사용해 음수값을 입력함으로써 데이터를 감소시킬 수도 있다.
```shell

> HINCRBY user:123 channel:3135 -1
(integer) 26
```
### DAU 구하기
- DAU(Daily Active User)는 하루 동안 서비스에 방문한 사용자의 수를 의미한다.
- 하루에 여러 번 방문했다 하더라도 한 번으로 카운팅되는 값으로, 실제 서비스를 이용한 사용자의 유니크한 수를 파악할 수 있는 지표다.
- 애플리케이션의 사용자 접근 로그와 같은 접속 로그를 활용해 날마다 배치 처리를 수행하는 방식으로 DAU를 계산할 수 있지만 이런 방식으로는 실시간 데이터는 확인할 수 없다.
- 하루 동안 방문했던 유저 ID를 Set에 저장하는 방법은 하루 1000만명 이상의 유저가 방문하는 큰 서비스라면 이럴 경우 하나의 키 안에 너무 많은 아이템이 저장될 수 있으며, 이는 곧 성능의 저하로 이어질 수 있다.
- 레디스의 비트맵을 이용하면 메모리를 효율적으로 줄이면서도 실시간으로 서비스의 DAU를 확인할 수 있다.
- 사용자 ID는 String 자료 구조에서 하나의 비트로 표현될 수 있다.
- 그렇기에 1천만명의 사용자는 1천만개의 비트로 나타낼 수 있으며, 이는 대략 1.2MB 크기에 해당한다. 레디스에서 String의 최대 길이는 512MB 이기 때문에, 하나의 키를 사용해 1천만명의 사용자를 카운팅하는 것은 문제없이 가능하다.
- 2022년 11월 6일 방문한 유저 id를 구하기 위해서는 키가 uv:20221106인 데이터를 만든 뒤 접속한 유저 id의 bit를 1로 설정하면 된다.
- id가 14인 유저가 접근했을 때에는 다음과 같이 오프셋 14를 1로 설정해준다.
```shell

> SETBIT uv:20221106 14 1
(integer) 0
```
- 해당 일자에 접근한 유저수를 확인할 때에는 BITCOUNT 커맨드를 사용할 수 있다.
```shell

> BITCOUNT uv:20221106
(integer) 3
```
- 비트맵에서 BITOP 커맨드를 사용하면 AND, OR, XOR, NOT 연산을 할 수 있으며, 레디스 서버에서 바로 계산된 결과를 가져올 수 있어 개별 비트를 가져와 서버에서 처리하는 번거로움을 줄여줄 수 있다.
- 게임에서 출석 이벤트를 진행하기 위해 특정 기간 동안 매일 방문한 사용자를 구하고 싶을 수 있다.
```shell

> BITOP AND event: 202211 uv: 20221101 uv: 20221102 uv: 20221103
(integer) 2
```
- BITOP AND 커맨드를 이용하면 3일 동안 연속 출석한 유저의 정보를 새로운 비트맵 자료 구조인 event:202211로 얻을 수 있다.
```shell

> GET event: 202211
"\x01\x02"
```
```

bitslist = []
for _, char in enumerate(result):
    bits = [(ord(char) »> i) & 1 for i in range(7, -1, -1)]
    bitslist += bits
>>> print bitslist
[e, e, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]
```
- 위의 예제에서 event:202211라는 키에 저장된 "\X01\x02" 값을 결과 변수인 results에 저장한 후, 이 변수를 문자 단위로 순회하면서 비트연산을 수행한다.
### hyperloglog를 이용한 애플리케이션 미터링
- 클라우드 컴퓨팅의 특성 중 하나는 Pay as you go로, 즉 서비스를 사용한 만큼 지불한다는 것을 의미한다. 따라서 사용자가 얼마나 서비스를 사용했는지 정확하게 측정할 수 있어야 한다.

- 미터링 솔루션은 사용자의 서비스 사용 내역을 이용하기 때문에 대용량 데이터를 처리할 수 있어야 한다.
- 서비스의 규모에 따라 초당 수천 건 이상의 작업이 발생할 수 있으며, 따라서 미터링 솔루션은 높은 처리량과 낮은 대기 시간을 가져야 한다.
- 예를 들어 서버와 클라이언트에서 발생하는 로그를 수집하고 인덱싱해 사용자가 특정 로그를 검색하고 조회할 수 있는 서비스를 클라우드 환경에서 제공한다고 생각해보자.
- 이때 로그를 수집할 때마다 서비스의 API를 호출하고, 하나의 API 호출마다 건별 로 과금을 매기는 정책이 있다면 사용자별 API 호출 횟수를 카운팅해야 한다.
- 레디스의 hyperloglog
  - 집합 내의 유일한 데이터의 개수를 카운팅해야 한다.
  - 1% 미만의 오차는 허용 가능하다.
  - 카운팅할 때 사용한 정확한 데이터를 다시 확인하지 않아도 된다.
- 유저를 구분하는 ID를 키로 사용하고 API를 호출할 때마다 저장되는 로그의 식별자를 hyperloglog에 저장할 수 있다.
- 예를 들어 2022년 11월에 ID가 245인 유저의 호출 횟수를 계산하려면 API를 호출할 때마다 202211: user :245라는 키에 PFADD 커맨드를 사용해 로그 식별자를 저장하면 된다.
```shell

> PFADD 202211:user:245 49483
(integer) 1

> PFADD 202211:user: 245 32714
(integer) 1

> PFADD 202211:user: 245 49483
(integer) 1

> PFCOUNT 202211:user:245
(integer) 2
```
- PFCOUNT 커맨드를 이용하면 hyperloglog에 저장된 중복되지 않은 데이터의 개수를 확인할 수 있다.
- 이 예제에서는 PFADD 커맨드로 49483이라는 로그를 두 번 저장하고, 32714라는 로그를 한 번 저장했지만 PFCOUNT를 사용해 확인했을 때 저장된 값은 2개임을 알 수 있다.
- hyperloglog는 set과 비슷하지만 저장되는 용량은 12KB로 고정되기 때문에 공간을 굉장히 효율적으로 사용할 수 있다는 장점을 갖고 있다. 
- PFMERGE 커맨드를 이용하면 여러 개의 hyperloglog를 합칠 수 있으므로 분기별 또는 연도별 합산 데이터를 간편하게 계산할 수 있다.
```shell

> PFMERGE 2022:user:245 202211:user: 245 202212:user: 245
"OK"

> PFCOUNT 2022: user: 245
(integer) 7
```
## Geospatial Index를 이용한 위치 기반 애플리케이션 개발
### 위치 데이터란
- 사용자의 위치가 실시간으로 변할 때, 이 데이터를 신속하게 저장하고 처리할 수 있는 데이터 저장소는 다음과 같은 기능을 제공해야 한다.
  - 사용자의 현재 위치 파악
  - 사용자의 이동에 따른 실시간 변동 위치 업데이트
  - 사용자의 위치를 기준으로 근처의 장소 검색
- 모든 사용자의 정보를 1초마다 업데이트한다고 가정하면 사용자의 증가에 따른 위치 데이터는 몇십 배로 증가하게 된다.
- 또한 위치 데이터끼리의 연산(사용자 근처의 맛집 검색)은 위치 데이터를 가공해야 하는 것이기 때문에 까다롭게 처리될 수 있다.
### 레디스에서의 위치 데이터
- geo set과 Pub/Sub 기능을 함께 사용하면 특정 맛집에서 이벤트를 발생시킬 때 해당 지역 근처의 사용자에게 실시간 알림을 보내는 서비스를 간단하게 구축할 수 있다.
#### geo set
- geo set은 위치 공간 관리에 특화된 데이터 구조로, 각 위치 데이터는 경도와 위도의 쌍으로 저장된다. 이 데이터는 내부적으로 sorted set 구조로 저장된다.
```shell

GEOADD user 50.07146286003341 14.414496454175485 142
```
- 위치를 변경할 때에도 동일하게 GEOADD 커맨드를 사용할 수 있으며, 기존 데이터는 새로운 위치 데이터로 업데이트된다.
```shell

GEOADD restaurant 50.07146286003341 14.414496454175485 ukalendu
```
- 프라하의 맛집 ukalendu를 restarunt라는 키에 저장하는 예
- 저장된 데이터는 GEOPOS 커맨드로 조회할 수 있다.
```shell

> GEOPOS restaurant ukalendu
1) 1) "50.07146447896957397"
   2)"14.41449664654903273"
```
- 만약 호텔 근처의 식당을 찾고자 한다면, 호텔의 경도와 위도 값을 가져온 뒤 다음과 같이 GEOSEARCH 커맨드로 검색하면 1km 내에 있는 식당을 찾을 수 있다.
```shell

> GEOSEARCH restaurant fromlonlat 50.06824582815170288 14.41818466583587366 byradius 1 km
1) "ukalendu"
```
- 예제에서는 FROMLONLAT 옵션을 이용해 직접 경도와 위도를 지정한 뒤, 해당 위치 근처 1km 내의 데이터를 검색했다. 
- 동일한 데이터 세트 내에서 검색하는 경우 FROMMEMBER 옵션을 이용하면 위도와 경도를 직접 입력하지 않고도 원하는 데이터를 찾을 수 있다.
- BYRADIUS 옵션은 이와 같이 사용자가 지정한 반지름 값을 기준으로, 해당 위치에서 그 반지름만큼 떨어진 범위 내의 데이터를 검색한다.
- 반면 BYBOX 옵션은 width와 height 값을 추가로 지정함으로써, 특정 위치를 중심으로 한 직사라형 영역 내의 장소들을 검색할 수 있다.
- BYBOX 옵션을 사용할 때 주의해야 할 점은 width와 height를 설정하면 검색 범위가 기준점을 중심으로 좌우로 width만큼, 상하로 height 만큼의 거리를 포함하는 직사각형 영역으로 결정된다는 점이다.