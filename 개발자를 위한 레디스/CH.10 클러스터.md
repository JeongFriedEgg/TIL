# CH.10 클러스터

## 레디스 클러스터와 확장성
### 스케일 업 vs 스케일 아웃
- 확장성(scalability)은 운영중인 시스템에서 증가하는 트래픽에 유연하게 대응할 수 있는 능력을 뜻한다.
- 사용자나 데이터의 증가로 시스템이 처리할 수 있는 트래픽이 많아져야 할 때 용량 및 성능을 늘리기 위해 시스템의 확장이 필요한데, 이때 리소스를 투입하는 방식에 따라 스케일 업과 스케일 아웃으로 구분할 수 있다.
- 스케일 업이란 서버의 하드웨어를 높은 사양으로 업그레이드하는 것을 말한다.
- 서버에 디스크를 추가하거나 CPU나 메모리를 업그레이드함으로써 서버 능력을 증강 시키기 때문에 이를 수직 확장(Vertical scaling)이라고도 한다.
- 스케일 아웃은 장비를 추가해 시스템을 확장시키는 방식을 말한다.
- 비슷한 사양의 서버를 추가로 연결해 용랑뿐만 아니라 처리량도 나눠 성능을 높일 수 있다.
- 서버의 사양이 증가하는 것이 아니라 대수가 증가하는 것이므로 이를 수평 확장(horizontal scaling)이라고도 한다.
- 스케일 업 방식이 좀 더 간단하고 비용도 적게 들지만 하드웨어 허용 범위 내에서만 확장이 가능하기 때문에 업그레이드하는 데 한계가 있다.
- 스케일 아웃을 사용했을 때에는 장비를 추가하는 만큼 성능의 확장이 가능하지만, 데이터가 여러대의 서버에 분산 처리돼야하므로 분산처리에 대한 로직이 추가 개발돼야 한다.
### 레디스에서의 확장성
- 레디스를 운영하는 도중 키의 이빅션(eviction)이 자주 발생한다면 서버의 메모리를 증가시키는 스케일 업을 고려할 수 있다.
- 키의 이빅션은 레디스 인스턴스의 max-memory 만큼 데이터가 차 있을 때 또다시 데이터를 저장할 때 발생하는 것이므로, 서버의 메모리를 늘리고 레디스 인스턴스의 max-memory 값을 증가시키는 스케일 업을 통해 더 많은 데이터를 저장할 수 있다.
- 레디스는 단일 스레드로 동작하기 때문에 서버에 CPU를 추가한다고 해도 여러 CPU코어를 동시에 활용할 수 없다.
- 그러나 데이터를 여러 서버로 분할해 관리하면 다수의 서버에서 요청을 병렬로 처리할 수 있으므로, 서버 대수를 늘림으로써 처리랑을 선형적으로 확장시킬 수 있다.
### 레디스 클러스터의 기능
- 레디스를 클러스터 모드로 사용하면 추가적인 애플리케이션 아키텍처의 변경없이 여러 레디스 인스턴스간 수평확장이 가능해지며, 데이터의 분산처리와 복제, 자동 페일오버 기능 또한 사용할 수 있다.
#### 데이터 샤딩
- 데이터 저장소를 수평확장하며 여러 서버간에 데이터를 분할하는 데이터베이스 아키텍처 패턴을 샤딩이라 한다.
- 클러스터에서 데이터는 키를 이용해 샤딩되며 하나의 키는 항상 하나의 마스터 노드에 매핑된다.
- 클러스터의 모든 노드는 키가 저장돼야 할 노드를 알고 있기 때문에 클라이언트가 다른 노드에 데이터를 쓰거나 읽으려 할 때 키가 할당된 마스터 노드로 연결을 리디렉션한다.
- 클러스터에서 노드가 추가/변경되지 않는 이상 하나의 키는 특정 마스터에 매핑된다. 
- 매번 레디스에 키를 저장할 노드를 질의하지 않게 하기위해 클라이언트에서는 클러스터 내에서 특정키가 어떤 마스터에 저장돼 있는지의 정보를 캐싱할 수 있다.
- 이를 이용해 키를 찾아오는 시간을 단축시킬 수 있다.
#### 고가용성
- 클러스터는 각각 최소 3대의 마스터, 복제본 노드를 갖도록 구성하는 것이 일반적이며, 하나의 클러스터 구성에 속한 각 노드는 서로를 모니터링한다.
- 마스터 노드에 장애가 발생하면 이를 인지한 다른 노드들이 마스터에 연결됐던 복제본 노드를 마스터로 자동 페일오버시키기 때문에 사용자의 추가적인 개입없이 레디스의 가용성을 증가시킬 수 있다.
- 또한 마스터에 연결된 복제본의 개수를 파악해 잉여 복제본을 필요한 노드에 연결시키는 복제본 마이그레이션 작업을 수행하기도 한다.
- 모든 레디스 클리스터 노드는 다른 레디스 클러스터 노드에서 들어오는 연결을 수신하기 위한 추가 TCP 포트가 열려 있다.
- 클라이언트로부터 커맨드를 받는 TCP 포트와 독립되게 동작하며, 구성 파일에서 `cluster_bus_port` 값을 정의하지 않는다면 일반적으로 일반 포트에 10000을 더한 값으로 자동 설정된다.
- 클러스터는 모든 노드가 TCP 연결을 사용해 다른 모든 노드와 연결돼 있는 풀 메쉬(full-mesh) 토폴로지 형태다.
- 풀 메쉬 토폴로지 형태로 구성된 레디스 클러스터 구조이지만 노드 간 너무 많은 메시지를 교환하는 오버헤드는 걱정하지 않아도 된다.
- 가십 프로토콜과 구성 업데이트 메커니즘을 이용해 클러스터가 정상적인 상태에서는 노드 간 너무 많은 메시지를 교환하지는 않는다.
## 레디스 클러스터 동작 방법
### 해시슬롯을 이용한 데이터 샤딩
- 클러스터 구조에서 모든 데이터는 해시슬롯에 저장된다.
- 3대의 마스터 노드로 클러스터를 구성했을 때 해시슬롯은 분배된다.
  - 첫 번째 마스터 노드는 0부터 5460까지의 해시슬롯을 포함
  - 두 번째 마스터 노드는 5461부터 10922까지의 해시슬롯을 포함
  - 세 번째 마스터 노드는 10923부터 16383까지의 해시슬롯을 포함
- 레디스에 입력되는 모든 키는 하나의 해시슬롯에 매핑되며, 이때 다음 해시함수는 다음과 같다.
```text
HASH_SLOT = CRC16(key) mod 16384
```
- 키를 CRC16으로 먼저 한번 암호화한 다음 16384라는 값으로 나눈 나머지 값을 이용해 해시슬롯이 결정된다.
- 해시슬롯은 마스터 노드 내에서 자유롭게 옮겨질 수 있으며, 옮겨지는 중에도 데이터는 정상적으로 접근할 수 있다.
### 해시태그
- 클러스터를 사용할 때에는 다중키 커맨드를 사용할 수 없다.
- 다중키 커맨드는 한 번에 여러 키에 접근해 데이터를 가져오는 커맨드다.
```shell

MGET user1:name user2:name
```
- 레디스 클러스터에서는 서로 다른 해시슬롯에 속한 키에 대해서는 다중키 커맨드를 사용할 수 없다.
- 해시태그라는 기능을 사용하면 이런 문제를 해결할 수 있다.
- 키에 대괄호를 사용하면 전체키가 아닌 대괄호 사이에 있는 값을 이용해 해시될 수 있다. 이를 해시태그라 한다.
```shell

user:{123}:profile
user:{123}:account
```
### 자동 재구성
- 센티널 구조에서는 고가용성을 위해 센티널 인스턴스를 추가로 띄워야 했으며, 별개의 센티널 인스턴스가 레디스 노드를 감시하는 구조였다면, 클러스터 구조에서는 데이터를 저장하는 일반 레디스 노드가 서로 감시한다는 점에서 차이가 있다.
- 재구성은 총 두 가지다. 마스터 노드에 장애가 발생했을 때 복제본 노드를 마스터로 승격시키는 자동 페일오버와 잉여 복제본 노드를 다른 마스터에 연결시키는 복제본 마이그레이션이 있다.
#### 자동 페일오버
```text
   (장애)
┌ - - - - ┐      ┌─────────┐      ┌─────────┐
|  6001   |      │  6002   │      │  6003   │
|  Redis  |      │  Redis  │      │  Redis  │
└ - - - - ┘      └─────────┘      └─────────┘
     │                │                │
     ↓                ↓                ↓
┌─────────┐      ┌─────────┐      ┌─────────┐
│  6005   │      │  6006   │      │  6004   │
│  Redis  │      │  Redis  │      │  Redis  │
└─────────┘      └─────────┘      └─────────┘

┌─────────┐      ┌─────────┐      ┌─────────┐
│  6001   │      │  6002   │      │  6003   │
│  Redis  │      │  Redis  │      │  Redis  │
└─────────┘      └─────────┘      └─────────┘
     │                │                │
     ↓                ↓                ↓
┌ - - - - ┐      ┌─────────┐      ┌─────────┐
|  6005   |      │  6006   │      │  6004   │
|  Redis  |      │  Redis  │      │  Redis  │
└ - - - - ┘      └─────────┘      └─────────┘
   (승격)
```
- 6001번 마스터에 장애가 발생하면 6005번 복제본은 다른 마스터 노드들에게 페일오버를 시도해도될지 투표를 요청한다.
- 6005 노드에 또 다시 장애가 발생하면 어떻게 될까? 클러스터 내의 마스터가 하나라도 정상상태가 아닐 경우 전체 클러스터를 사용할 수 없게 된다.
```shell

cluster-require-full-coverage yes
```
- 해당 옵션의 기본값은 yes로, 레디스 클러스터에서 일부 해시슬롯을 사용하지 못하게 되면, 즉 일부 노드만 다운된 경우라도 데이터의 정합성을 위해 클러스터의 전체 상태가 fail이 돼, 문제가 생긴 해시슬롯을 포함한 전체 해시슬롯에 대한 데이터의 조작도 실패한다. 
- 만약 가용성이 중요한 서비스에서 클러스터 노드의 다운타임을 줄이고 싶다면 자동 복제본 마이그레이션이 가능하도록 아무 마스터 노드에 복제본을 하나 더 추가하는 것을 고려하는 것이 좋다.
#### 자동 복제본 마이그레이션
```text
   (장애)
┌ - - - - ┐      ┌─────────┐            ┌─────────┐
|  6001   |      │  6002   │            │  6003   │
|  Redis  |      │  Redis  │            │  Redis  │
└ - - - - ┘      └─────────┘            └─────────┘
     │                │                   │     │
     ↓                ↓                   ↓     ↓
┌─────────┐      ┌─────────┐      ┌─────────┐ ┌─────────┐
│  6005   │      │  6006   │      │  6004   │ │  6007   │
│  Redis  │      │  Redis  │      │  Redis  │ │  Redis  │
└─────────┘      └─────────┘      └─────────┘ └─────────┘

┌─────────┐      ┌─────────┐            ┌─────────┐
│  6001   │      │  6002   │            │  6003   │
│  Redis  │      │  Redis  │            │  Redis  │
└─────────┘      └─────────┘            └─────────┘
     │                │                   │     │
     ↓                ↓                   ↓     ↓
┌ - - - - ┐      ┌─────────┐      ┌─────────┐ ┌─────────┐
|  6005   |      │  6006   │      │  6004   │ │  6007   │
|  Redis  |      │  Redis  │      │  Redis  │ │  Redis  │
└ - - - - ┘      └─────────┘      └─────────┘ └─────────┘
   (승격)
   
┌─────────┐      ┌─────────┐            ┌─────────┐
│  6001   │      │  6002   │            │  6003   │
│  Redis  │      │  Redis  │            │  Redis  │
└─────────┘      └─────────┘            └─────────┘
     │                │                   │     │
     ↓                ↓                   ↓     ↓
┌ - - - - ┐      ┌─────────┐      ┌─────────┐ ┌ - - - - ┐
|  6005   |      │  6006   │      │  6004   │ │  6007   │
|  Redis  |      │  Redis  │      │  Redis  │ │  Redis  │
└ - - - - ┘      └─────────┘      └─────────┘ └ - - - - ┘
     ↑_____________________________________________⏌
                    복제본 마이그레이션
```
- 레디스 클러스터는 총 7개의 노드로 구성돼 있으며 6001, 6002 마스터는 각각 1개의 복제본을, 6003 노드는 2개의 복제본을 가지고 있다.
- 6001 노드에 장애가 발생하면 6005 노드가 마스터로 승격된다.
- 6005 마스터는 복제본이 없으며, 6002 노드는 1개의 복제본, 6003 노드는 2개의 복제본을 갖고 있다.
- 이 상황에서 레디스 클러스터는 각 마스터에 연결된 복제본 노드의 불균형을 파악해 6003에 연결돼 있는 2개의 복제본 중 하나의 복제본을 6005의 복제본이 되도록 이동시킨다.
- 이를 복제본 마이그레이션(replica migration)이라 한다.
- 복제본 마이그레이션은 모든 마스터가 적어도 1개 이상의 복제본에 의해 복제되는 것을 보장하며, 이를 이용해 클러스터 전체의 안정성을 향상시킨다.
```shell

cluster-allow-replica-migration yes
cluster-migration-barrier 1
```
- 마이그레이션은 `cluster-allow-replica-migration` 옵션이 yes일 때 동작하며, 기본값은 yes다.
- `cluster-migration-barrier`는 복제본을 마이그레이션하기 전 마스터가 가지고 있어야 할 최소 복제본의 수를 의미한다.
## 레디스 클러스터 실행하기
- 레디스를 클러스터 모드로 사용하려면 최소 3개의 마스터 노드가 있어야 한다.
- 실제 운영목적으로 사용할 때는 3개의 마스터에 각각 복제본을 추가해 총 6개의 노드로 클러스터를 구성하는 것이 일반적이다.
### 클러스터 초기화
```shell

cluster-enabled yes
```
- `cluster-enabled`설정을 yes로 변경해 레디스를 클러스터 모드로 변경한 다음 각기 다른 서버 6대에 레디스를 실행시키자.
```shell

redis-cli -cluster create [host:port] --cluster-replicas 1
```
- `--cluster-replicas 1` 옵션은 각 마스터마다 1개의 복제본을 추가할 것임을 의미한다.
```shell

$ src/redis-cli --cluster create 192.168.0.11:6379 192.168.0.22:6379
192.168.0.33:6379 192.168.0.44:6379 192.168.0.55:6379 192.168.0.66:6379
--cluster-replicas 1 -a nhncloud
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
>>> Performing hash slots allocation on 6 nodes...
Master[0] -> Slots 0 - 5460
Master [1] -> Slots 5461 - 10922
Master [2] -> Slots 10923 - 16383
Adding replica 192.168.0.55:6379 to 192.168.0.11:6379
Adding replica 192.168.0.66:6379 to 192.168.0.22:6379
Adding replica 192.168.0.44:6379 to 192.168.0.33:6379
M: 5a15c78c1ca9f39aceab55357d69c193756a1445 192.168.0.11:6379
   slots: [0-5460] (5461 slots) master
M: 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05 192.168.0.22:6379
   slots: [5461-10922] (5462 slots) master
M: ab1b4edfa9085b104fc3fd9f3f9d5a740f7dea66 192.168.0.33:6379
   slots: [10923-16383] (5461 slots) master
S: 52e66ec38afe31063a9821f03a9dab9ae3cdf9dd 192.168.0.44:6379
   replicates ablb4edfa9085b104fc3fd9f3f9d5a740f7dea66
S: c7fa336489d69e3dc9e5068374a19ca9376e9c20 192.168.0.55:6379
   replicates 5a15c78c1ca9f39aceab55357d69c193756a1445
```
- 해시슬롯은 마스터에만 할당되며 복제본 노드에는 할당되지 않음을 알 수 있다.
- 복제본 노드는 마스터와 동일한 데이터를 저장하기 때문에 해시슬롯 내부의 데이터를 동일하게 저장하긴 하지만, 해시슬롯을 할당받진 않는다.
```shell

slots: [0- 5460] (5461 slots) master <- 마스터 노드
slots: (0 slots) slave <- 복제본 노드
```
### 클러스터 상태 확인하기
- CLUSTER NODES 커맨드를 이용해 현재 클러스터의 상태를 확인할 수 있다.
```shell

<id> <ip:port@cport> <flags> <master> <ping-sent> <pong-recv> <config-epoch>
<link-state> <slot> <slot>...<slot>
```
### redis-cli를 이용해 클러스터 접근하기와 리디렉션
- 레디스 클러스터에 접속하기 위해서는 클러스터 모드를 지원하는 레디스 클라이언트가 필요하다.
```shell

$ redis-cli
127.0.0.1:6379> set user:1 true
(error) MOVED 10778 192.168.0.22:6379
```
- user:1이라는 키를 입력하려 시도했으나, 해당 키가 들어가야 할 해시슬롯은 10778이며, 그 해시슬롯을 가지고 있는 레디스는 ip가 192.168.0.22인 마스터 노드라는 응답을 받았다.
- 일반적인 클라이언트를 이용해 데이터를 넣을 때에는 데이터가 저장될 수 있는 노드가 정해져 있고 해당 노드에만 키에 대한 커맨드를 수행시킬 수 있음을 의미한다.
- 이러한 불편함을 줄이기 위해 Jedis, Redisson 등의 레디스 클라이언트들은 클러스터 모드 기능을 제공한다.
- redis-c1i를 사용한다면 -c 옵션을 추가해 클러스터 모드로 사용할 수 있고, 이 경우에 리디렉션 기능이 제공된다.
```shell

$ redis-cli -c
127.0.0.1:6379> set user:1 true
-> Redirected to slot [10778] located at 192.168.0.22:6379
OK
192.168.0.22:6379>
```
- 데이터를 저장하자 Redirected됐다는 메시지가 뜬 뒤, 데이터가 정상적으로 저장돼 OK 응답을 받은 것을 확인할 수 있다.
- 그 뒤 연결 ip는 로컬을 의미하는 주소인 127.0.0.1에서 실제 데이터가 저장된 노드인 192.168.0.22로 변경돼 있다.
- redis-cli라는 클라이언트가 연결을 192.168.0.11에서 저장하고자 하는 키가 있는 192.168.0.22로 자동으로 옮겼다는 것을 의미한다.
- 대부분의 레디스 클라이언트는 이렇게 리디렉션한 정보를 캐싱해 맵을 생성하게 되는데, 다음번 같은 키에 대해 커맨드를 수행해야 할 경우 이번과 같이 에러를 반환해서 커넥션을 옮겨가는 과정을 거치지 않고 캐싱된 노드로 바로 커맨드를 보낼 수 있게 해 클러스터의 성능을 향상시킬 수 있게 된다.
### 페일오버 테스트
#### 커맨드를 이용한 페일오버 발생(수동 페일오버)
- 수동으로 페일오버시키려면 페일오버시키고자 하는 마스터에 1개 이상의 복제본이 연결돼 있어야 한다.
- 페일오버를 발생시킬 복제본 노드에서 `cluster failover` 커맨드를 실행하면 페일오버를 발생시킬 수 있다.
```text

┌───────────────────┐      ┌───────────────────┐      ┌───────────────────┐
│ 192.168.0.11:6379 │      │ 192.168.0.22:6379 │      │ 192.168.0.33:6379 │
│     [ Redis ]     │      │     [ Redis ]     │      │     [ Redis ]     │
│     (Master)      │      │     (Master)      │      │     (Master)      │
└───────────────────┘      └───────────────────┘      └───────────────────┘
          │                          │                          │
          ↓                          ↓                          ↓
┌───────────────────┐      ┌───────────────────┐      ┌───────────────────┐
│ 192.168.0.55:6379 │      │ 192.168.0.66:6379 │      │ 192.168.0.44:6379 │
│     [ Redis ]     │      │     [ Redis ]     │      │     [ Redis ]     │
│      (Slave)      │      │      (Slave)      │      │      (Slave)      │
└───────────────────┘      └───────────────────┘      └───────────────────┘
```
```shell

192.168.0.55:6379> INFO REPLICATION
# Replication
role: slave
master_host: 192.168.0.11
master_port:6379
.
.
.
192.168.0.55:6379> CLUSTER FAILOVER
OK
```
```shell

192.168.0.55:6379> INFO REPLICAITON
# Replication
role: master
connected_slaves: 1
slave : ip=192.168.0.11,port=6379, state=online,offset=613998,1ag=0
```
- 수동 페일오버가 진행되는 동안 기존 마스터에 연결된 클라이언트는 잠시 블락된다. 
- 페일오버를 시작하기 전 복제 딜레이를 기다린 뒤, 마스터의 복제 오프셋을 복제본이 따라잡는 작업이 완료되면 페일오버를 시작한다.
- 페일오버가 완료되면 클러스터의 정보를 변경하고, 모든 작업이 완료되면 클라이언트는 새로운 마스터로 리디렉션된다.
#### 마스터 동작을 중지시켜 페일오버 발생(자동 페일오버)
```shell

$ redis-cli -h <master-host> -p <master-port> shutdown
```
- 클러스터 구조에서 복제본은 redis.conf에 지정한 `cluster-node-timeout` 시간 동안 마스터에서 응답이 오지 않으면 마스터의 상태가 정상적이지 않다고 판단해 페일오버를 트리거한다.
## 레디스 클러스터 운영하기
### 클러스터 리샤딩
- 마스터 노드가 가지고 있는 해시슬롯 중 일부를 다른 마스터로 이동하는 것을 리샤딩이라 한다.
- 리샤딩은 redis-cli에서 `cluster reshard` 옵션을 이용해 수행할 수 있다.
```shell

$ redis-cli --cluster reshard 192.168.0.66 6379
>>> Performing Cluster Check (using node 192.168.0.66:6379)
S: f6c15801602a4f5e89458945362ce3e6cf1d6cd3 192.168.0.66:6379
slots: (0 slots) slave
replicates 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05
M: 5a15c78c1ca9f39aceab55357d69c193756а1445 192.168.0.11:6379
slots: [0-5460] (5461 slots) master
1 additional replica(s)
M: 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05 192.168.0.22:6379
slots: [5461-10922] (5462 slots) master
1 additional replica(s)
M: ab1b4edfa9085b104fc3fd9f3f9d5a740f7dea66 192.168.0.33:6379
slots:[10923-16383] (5461 slots) master
1 additional replica(s)
S: 52e66ec38afe31063a9821f03a9dab9ae3cdf9dd 192.168.0.44:6379
slots: (0 slots) slave
replicates ablb4edfa9085b104fc3fd9f3f9d5a740f7dea66
S: c7fa336489d69e3dc9e5068374a19ca9376e9c20 192.168.0.55:6379
slots: (0 slots) slave
replicates 5a15c78c1ca9f39aceab55357d69c193756a1445
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
How many slots do you want to move (from 1 to 16384)?
```
- 클러스터에 속한 여러 노드 중 하나의 노드를 지정하면 해당 노드가 속한 클러스터 구조를 파악한 뒤 연결된 다른 노드의 정보를 찾아와 다음과 같이 보여준다.
- 마스터 노드뿐만 아니라 레플리카 노드 중 하나를 지정하더라도 리샤딩 동작은 동일하게 수행된다.
```shell
How many slots do you want to move (from 1 to 16384)? 100
What is the receiving node ID?
```
- 첫 번째로, 이동시킬 슬롯의 개수를 정해야 한다.
- 이 해시슬롯을 받을 노드의 ID를 입력한다.
```shell

How many slots do you want to move (from 1 to 16384)? 100
What is the receiving node ID? ablb4edfa9085b104fc3fd9f3f9d5a740f7dea66
Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1:
```
- all을 입력한다면 모든 마스터 노드에서 조금씩 이동할 것을 의미한다.
- 해시슬롯을 가져올 마스터 ID를 지정하고 싶다면 하나씩 입력한 뒤 done을 입력해주면 된다.
```shell

Source node #1: all
Ready to move 100 slots.
  Source nodes:
    M: 5a15c78c1ca9f39aceab55357d69c193756а1445 192.168.0.11:6379
      slots: [0-5460] (5461 slots) master
      1 additional replica(s)
    M: 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05 192.168.0.22:6379
      slots: [5461-10922] (5462 slots) master
      1 additional replica(s)
  Destination node:
    M: ab1b4edfa9085b104fc3fd9f3f9d5a740f7dea66 192.168.0.33:6379
      slots: [10923-16383] (5461 slots) master
      1 additional replica(s)
      
Resharding plan:
    Moving slot 5461 from 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05
    Moving slot 5462 from 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05
    Moving slot 5463 from 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05
    Moving slot 5464 from 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05
.
.
.
Moving slot 5509 from 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05
    Moving slot 5510 from 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05
    Moving slot 5511 from 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05
    Moving slot 0 from 5a15c78c1ca9f39aceab55357d69c193756a1445
    Moving slot 1 from 5a15c78c1ca9f39aceab55357d69c193756a1445
    Moving slot 2 from 5a15c78c1ca9f39aceab55357d69c193756a1445
    Moving slot 3 from 5a15c78c1ca9f39aceab55357d69c193756a1445
.
.
.
Moving slot 44 from 5a15c78c1ca9f39aceab55357d69c193756a1445
    Moving slot 45 from 5a15c78c1ca9f39aceab55357d69c193756a1445
    Moving slot 46 from 5a15c78c1ca9f39aceab55357d69c193756a1445
    Moving slot 47 from 5a15c78c1ca9f39aceab55357d69c193756а1445
    Moving slot 48 from 5a15c78c1ca9f39aceab55357d69c193756a1445
Do you want to proceed with the proposed reshard plan (yes/no)?
```
- 해시슬롯을 이동시킬 노드의 입력이 끝나면 리샤딩이 진행될 소스와 데스티네이션의 마스터 노드 정보를 확인할 수 있으며, 리샤딩 플랜을 보여준다.
- `cluster check` 커맨드는 `cluster nodes`보다 조금 더 자세한 구성을 확인할 수 있다.
```shell

$ redis-cli --cluster check 192.168.0.22 6379
192.168.0.22:6379 (73abfbb3...) -> 1 keys | 5411 slots | 1 slaves.
192.168.0.11:6379 (5a15c78c...) > 0 keys | 5412 slots | 1 slaves.
192.168.0.33:6379 (ablb4edf...) -> 0 keys | 5561 slots | 1 slaves.
[OK] 1 keys in 3 masters.
0.00 keys per slot on average.
>>> Performing Cluster Check (using node 192.168.0.22:6379)
M: 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05 192.168.0.22:6379
    slots: [5512-10922] (5411 slots) master
  1 additional replica(s)
S: c7fa336489d69e3dc9e5068374a19ca9376e9c20 192.168.0.55:6379
    slots: (0 slots) slave
    replicates 5a15c78c1ca9f39aceab55357d69c193756a1445
S: 52e66ec38afe31063a9821f03a9dab9ae3cdf9dd 192.168.0.44:6379
    slots: (0 slots) slave
    replicates ablb4edfa9085b104fc3fd9f3f9d5a740f7dea66
M: 5a15c78c1ca9f39aceab55357d69c193756а1445 192.168.0.11:6379
    slots: [49-5460] (5412 slots) master
    1 additional replica(s)
S: f6c15801602a4f5e89458945362ce3e6cf1d6cd3 192.168.0.66:6379
    slots: (0 slots) slave
    replicates 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05
M: ab1b4edfa9085b104fc3fd9f3f9d5a740f7dea66 192.168.0.33:6379
    slots: [0-48], [5461-5511], [10923-16383] (5561 slots) master
    1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
```
- 192.168.0.33 IP의 노드는 0부터 48, 5461부터 5511, 10923부터 16383까지의 총 5,561개의 해시슬롯을 갖게 됐음을 알 수 있다.
### 클러스터 리샤딩- 간단 버전
- 운영상 클러스터 내에서 슬롯을 이동시킬 일이 자주있거나, 자동화를 하고 싶을 경우 위와 같은 커맨드를 이용해 사용자와의 인터렉션 없이 바로 슬롯을 이동시키는 방법도 존재한다.
- 커맨드를 실행하자마자 바로 데이터가 옮겨지기 때문에 중간에 취소와 확인이 어렵다.
```shell

redis-cli --cluster reshard <host>:<port> --cluster-from <node-id>
--cluster-to <node-id> --cluster-slots <number of slots> --cluster-yes
```
```shell

$ redis-cli --cluster reshard 192.168.0.11:6379 --cluster-from 5a15c78c1ca9f
39aceab55357d69c193756a1445 --cluster-to ab1b4edfa9085b104fc3fd9f3f9d5a740f7
dea66 --cluster-slots 100 --cluster-yes
>>> Performing Cluster Check (using node 192.168.0.11:6379)
M: 5a15c78c1ca9f39aceab55357d69c193756а1445 192.168.0.11:6379
    slots: [49-5460] (5412 slots) master
    1 additional replica(s)
M: 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05 192.168.0.22:6379
    slots: [5512-10922] (5411 slots) master
    1 additional replica(s)
S: f6c15801602a4f5e89458945362ce3eбcf1d6cd3 192.168.0.66:6379
    slots: (0 slots) slave
    replicates 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05
S: 52e66ec38afe31063a9821f03a9dab9ae3cdf9dd 192.168.0.44:6379
    slots: (0 slots) slave
    replicates ablb4edfa9085b104fc3fd9f3f9d5a740f7dea66
M: ab1b4edfa9085b104fc3fd9f3f9d5a740f7dea66 192.168.0.33:6379
    slots: [0-48], [5461-5511], [10923-16383] (5561 slots) master
    1 additional replica(s)
S: c7fa336489d69e3dc9e5068374a19ca9376e9c20 192.168.0.55:6379
    slots: (0 slots) slave
    replicates 5a15c78c1ca9f39aceab55357d69c193756a1445
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
Ready to move 100 slots.
    Source nodes:
        M: 5a15c78c1ca9f39aceab55357d69c193756а1445 192.168.0.11:6379
            slots: [49-5460] (5412 slots) master
            1 additional replica(s)
    Destination node:
        M: ab1b4edfa9085b104fc3fd9f3f9d5a740f7dea66 192.168.0.33:6379
            slots: [0-48], [5461-5511], [10923-16383] (5561 slots) master
            1 additional replica(s)
```
- `--cluster-yes` 커맨드는 모든 프롬프트에 자동으로 yes를 입력하겠다는 것을 의미한다.
- 위의 커맨드를 시작하자마자 자동으로 클러스터 리샤딩 작업이 진행된다.
```shell

$ redis-cli cluster nodes
5a15c78c1ca9f39aceab55357d69c193756а1445 192.168.0.11:6379@16379 master - 0
1670856942314 1 connected 149-5460
73abfbb3872609862c9fcc229cdf1c3a3c0f2d05 192.168.0.22:6379@16379 master - 0
1670856943819 2 connected 5512-10922
f6c15801602a4f5e89458945362ce3e6cf1d6cd3 192.168.0.66:6379@16379
myself, slave 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05 0 1670856942000 2
connected
ab1b4edfa9085b104fc3fd9f3f9d5a740f7dea66 192.168.0.33:6379@16379 master - 0
1670856943000 7 connected 0-148 5461-5511 10923-16383
52e66ec38afe31063a9821f03a9dab9ae3cdf9dd 192.168.0.55:6379@16379 slave ab1b4
edfa9085b104fc3fd9f3f9d5a740f7dea66 0 1670856942615 7 connected
C7fa336489d69e3dc9e5068374a19ca9376e9c20 192.168.0.44:6379@16379 slave 5a15c
78c1ca9f39aceab55357d69c193756a1445 0 1670856942000 1 connected
```
- 192.168.0.33 IP의 노드가 가지고 있는 해시슬롯이 0-148, 5461-5511, 10923-16383으로 변경된 것을 알 수 있다.
### 클러스터 확장- 신규 노드 추가
- 클러스터를 확장시키기 위해 마스터로서 새로운 노드를 추가하고 싶을 수도 있고, 가용성을 위해 복제본을 추가하고 싶을 수도 있다.
- 두 경우 모두 추가하고자 하는 레디스에는 데이터가 저장되지 않은 상태여야 한다.
- 추가하고자 하는 노드도 마찬가지로 설정 파일에 `cluster-enabled yes`를 추가해 클러스터 노드로 실행된 상태여야 한다.
#### 마스터로 추가하기
- `--cluster add-node` 커맨드를 사용하면 클러스터에 신규 마스터 노드를 추가할 수 있으며, 첫 번째 인수는 새로 추가하고자 하는 레디스 노드, 두 번째 인수는 기존 클러스터에 속한 노드 중 1개의 노드를 지정해야 한다.
```shell

redis-cli - cluster add-node <추가할 노드 IP:PORT> <기존 노드 IP:PORT>
```
```shell

$ redis-cli cluster nodes
73abfbb3872609862c9fcc229cdf1c3a3c0f2d05 192.168.0.22:6379@16379 master - 
01671034190583 13 connected 5461-10922
f6c15801602a4f5e89458945362ce3e6cf1d6cd3 192.168.0.66:6379@16379 
slave 73abfbb3872609862c9fcc229cdf1c3a3c0f2d05 0 1671034190000 13 connected
52e66ec38afe31063a9821f03a9dab9ae3cdf9dd 192.168.0.55:6379@16379
slave ab1b4edfa9085b104fc3fd9f3f9d5a740f7dea66 0 1671034190683 11 connected
ab1b4edfa9085b104fc3fd9f3f9d5a740f7dea66 192.168.0.33:6379@16379 master - 
01671034190000 11 connected 10923-16383
5а15c78c1ca9f39aceab55357d69c193756a1445 192.168.0.11:6379@16379
myself,master - 0 1671034189000 12 connected 
0-546073173c7c742a5659a25e41e0cf288fe24429e2fd 192.168.0.77:6379@16379 master - 
01671034189000 0 connected
c7fa336489d69e3dc9e5068374a19ca9376e9c20 192.168.0.44:6379@16379
slave 5a15c78c1ca9f39aceab55357d69c193756a1445 0 1671034190583 12 connected
```
- 192.168.0.77 노드가 마스터 노드로서 클러스터에 추가된 것을 볼 수 있다.
- 하지만 이 상태의 노드는 할당된 해시슬롯이 없기 때문에 데이터를 보유할 수 없으며, 데이터를 저장하려면 리샤딩 기능을 사용해 직접 해시슬롯을 할당하는 과정을 거쳐야 한다.
#### 복제본으로 추가하기
- 신규 노드를 복제본으로 추가하는 방법은 마스터를 추가하는 방법과 동일하며, `--cluster-slave` 옵션을 추가해야 한다.
```shell

redis-cli - cluster add-node <추가할 노드 IP:PORT> <기존 노드 IP:PORT>
--cluster-slave [--cluster-master-id <기존 마스터 ID>]
```
- `--cluster-master-id` 옵션을 이용해 복제본의 마스터가 될 노드를 지정해주면 신규로 추가하는 노드는 지정한 마스터에 복제본으로 연결된다.
- 만약 해당 옵션 없이 `--cluster-slave` 옵션을 이용해 노드를 추가할 때는 추가되는 노드가 임의의 마스터의 복제본으로 연결된다.
- 만약 클러스터가 대칭적인 구조가 아닐 때에는 복제본이 적게 연결돼 있는 마스터를 파악해 그중 한 마스터의 복제본이 되도록 지정해 균형을 맞추게 된다.
```text

┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐
│ 192.168.0.11:6379 │  │ 192.168.0.22:6379 │  │ 192.168.0.33:6379 │
│     [ Redis ]     │  │     [ Redis ]     │  │     [ Redis ]     │
│     (Master)      │  │     (Master)      │  │     (Master)      │          ┌───────────────────┐
└───────────────────┘  └───────────────────┘  └───────────────────┘          │ 192.168.0.77:6379 │
          │                      │                      │            ←─────  │     [ Redis ]     │
          ↓                      ↓                      ↓                    │     (Master)      │
┌ - - - - - - - - - ┐  ┌───────────────────┐  ┌───────────────────┐          └───────────────────┘
| 192.168.0.55:6379 |  │ 192.168.0.66:6379 │  │ 192.168.0.44:6379 │                    |
|     [ Redis ]     |  │     [ Redis ]     │  │     [ Redis ]     │                    |
|      (Slave)      |  │      (Slave)      │  │      (Slave)      │                    |
└ - - - - - - - - - ┘  └───────────────────┘  └───────────────────┘                    |
      (장애)    ↑_______________________________________________________________________|
```
- 192.168.0.55 IP의 복제본이 종료돼 192.168.0.11 IP의 마스터 노드는 아무런 복제본이 없는 상태에서 192.168.0.77 IP의 노드를 신규 추가하게 되면 신규로 추가하는 노드는 복제본이 없는 192.168.0.11 IP의 마스터 노드의 복제본이 되도록 구성된다.
### 노드 제거하기
- 클러스터에서 노드를 제거하기 위해서는 `del-node` 커맨드를 사용한다.
```shell

redis-cli--cluster del-node <기존 노드 IP:PORT> <삭제할 노드 ID>
```
- 제거하려는 노드가 마스터 노드인지 복제본 노드인지에 상관없이 모든 노드를 같은 방식으로 삭제할 수 있지만, 마스터 노드의 경우 제거하기 전 노드에 저장된 데이터가 없는 상태여야 한다.
- 즉, 할당된 해시슬롯이 하나도 없도록 해시슬롯을 모두 다른 노드로 리샤딩하는 작업이 선행돼야 한다.
- 혹은 수동으로 페일오버를 진행한 뒤 노드의 역할을 복제본으로 만든 뒤 클러스터에서 제거할 수도 있다.
```shell

$ redis-cli --cluster del-node 192.168.0.11:6379 73173c7c742a5659a25e41e0cf288fe24429e2fd
>>> Removing node 73173c7c742a5659a25e41e0cf288fe24429e2fd from cluster
192.168.0.11:6379
>>> Sending CLUSTER FORGET messages to the cluster...
>>> Sending CLUSTER RESET SOFT to the deleted node.
```
#### CLUSTER FORGET
- 클러스터를 제거하기 위해서는 제거될 노드에서 클러스터 구성 데이터를 지우는 것뿐만 아니라, 클러스터 내의 다른 노드들에게도 해당 노드를 지우라는 커맨드를 함께 보내야 한다.
- 그렇지 않다면 클러스터 내부의 다른 노드는 여전히 해당 노드의 ID와 주소를 기억하고 있게 된다. 
- `CLUSTER FORGET <node-id>` 커맨드를 수신한 노드는 노드 테이블에서 제거할 노드의 정보를 지운 뒤, 60초 동안은 이 노드 ID를 가지고 있는 노드와 신규로 연결되지 않도록 설정한다. 
- 클러스터 구성에서 노드들은 가십 프로토콜을 이용해 통신하기 때문에 신규 클러스터 노드를 자동으로 감지해 새로운 노드로 추가할 수 있다.
- 따라서 60초 동안 제거한 노드의 ID가 다시 추가되는 것을 차단하지 않으면 다른 노드에 의해 제거된 노드를 다시 클러스터에 추가할 가능성이 존재한다.
#### CLUSTER RESET
- 클러스터 리셋 커맨드는 제거될 노드에서 수행된다.
```shell

CLUSTER RESET [SOFT/HARD]
```
- HARD RESET을 진행할 때에는 1에서 5번 과정이 모두 수행되며, SOFT RESET에서는 1에서 3번까지의 과정만 수행된다.
1. 클러스터 구성에서 복제본 역할을 했었다면 노드는 마스터로 전환되고, 노드가 가지고 있던 모든 데이터셋은 삭제된다. 노드가 마스터이고 저장된 키가 있다면 리셋작업이 중단된다.
2. 노드가 해시슬롯을 가지고 있었다면 모든 슬롯이 해제되며, 만약 페일오버가 진행되는 과정이었다면 페일오버에 대한 진행상태도 초기화된다.
3. 클러스터 구성내의 다른 노드 데이터가 초기화된다. 기존에 클러스터 버스를 통해 연결됐던 노드를 더 이상 인식할 수 없다.
4. currentEpoch, configEpoch, lastvoteEpoch 값이 0으로 초기화된다.
5. 노드의 ID가 새로운 임의 ID로 변경된다.
### 레디스 클러스터로의 데이터 마이그레이션
- 기존에 싱글 혹은 센티널 구성으로 사용하고 있던 레디스 인스턴스를 가용성과 확장성을 위해 클러스터 구성의 레디스로 마이그레이션하고 싶을 수 있다.
- 기존 애플리케이션에서 다중키 커맨드를 사용하지 않았을 경우에는 커넥션 변경 이외의 데이터 저장 로직은 문제가 되지 않으며, 사용했을 경우라면 해시태그를 사용하도록 애플리케이션 로직을 일부 수정해야 한다.
- 데이터를 전달받을 클러스터 노드에서 소스 레디스 노드로 데이터 import 요청을 한다.
- 데이터가 저장될 클러스터 노드는 해시슬롯 16,384개가 정상적으로 할당된 정상상태여야 하며, 클러스터 내의 마스터 노드에 모두 접근 가능한 상태로 준비돼 있어야 한다.
- 운영중인 레디스의 데이터를 마이그레이션할 때에는 소스 레디스에 연결된 클라이 언트를 모두 중단시키는 것이 좋다.
- 마이그레이션 도중 원본 레디스 노드에서 변경되거나 추가된 데이터는 마이그레이션되는 클러스터에 반영되지 않기 때문이며, 경우에 따라 서비스에 점검을 건 상태에서 진행해야 할 수도 있다.
```shell

redis-cli --cluster import 192.168.0.11:6379 --cluster-from 192.168.0.88:6379 --cluster-copy
```
### 복제본을 이용한 읽기 성능 향상
- 레디스 클라이언트는 기본적으로 키를 요청하면 키를 갖고 있는 마스터 노드로 연결을 리디렉션한다.
- 마스터에 연결된 복제본 노드는 같은 데이터를 갖고 있기 때문에 키를 읽을 수 있지만, 이 경우에도 우선 마스터로 연결이 변경된다.
```shell

$ redis-cli -h 192.168.0.55
192.168.0.55:6379> get hello
(error) MOVED 866 192.168.0.11:6379
192.1680.55:6379>

$ redis-cli -h 192.168.0.55 -c
192.168.0.55:6379> get hello
-> Redirected to slot [866] located at 192.168.0.11:6379
"world"
192.168.0.11:6379>
```
- 마스터에 데이터를 읽어가는 부하가 집중되는 경우 데이터를 쓰는 커넥션은 마스터에, 읽기는 복제본에서 수행할 수 있도록 커넥션을 분배시킨다면 읽기성능을 향상시킬 수 있다.
- 복제본으로 맺어지는 커넥션을 READONLY 모드로 변경해 클라이언트가 복제본 노드에 있는 데이터를 직접 읽을 수 있게 할 수 있다.
```shell

$ redis-cli -h 192.168.0.55 -c
192.168.0.55:6379> readonly
OK
192.168.0.55:6379> get hello
"world"
```
## 레디스 클러스터 동작 방법
### 하트비트 패킷
- 레디스 클러스터 노드들은 지속적으로 서로의 상태를 확인하기 위해 PING, PONG 패킷을 주고받는다.
- 이 두 패킷을 묶어서 하트비트(Hearbeat) 패킷이라 하며, 일반적으로 클러스터가 주고받는 유형의 패킷에 가십섹션이 추가된 형태를 띤다.
- 패킷의 헤더
  - 노드 ID
  - 현재 에포크/구성 에포크 : 분산 환경에서 일관성을 유지하기 위한 정보
  - 노드 플래그 : 노드가 마스터인지 혹은 복제본인지 등의 노드 정보
  - 비트맵 : 마스터가 제공하는 해시슬롯의 비트맵 정보. 복제본인 경우 마스터의 정보
  - TCP 포트 : 발신 노드의 TCP 포트
  - 클러스터 포트 : 발신 노드의 노드 간 커뮤니케이션을 위한 포트
  - 클러스터 상태 : 발신 노드 관점에서 봤을 때의 클러스터 상태(down/ok)
  - 마스터 노드 ID : 복제본 노드인 경우 마스터의 노드 ID
- 하트비트 패킷의 경우 위의 헤더에 가십섹션을 추가로 포함하고 있다.
- 이 섹션은 패킷을 발신하는 노드가 알고있는 클러스터 내의 다른 노드 정보를 나타낸다.
- 하트비트 패킷을 받은 클러스터 노드는 다른 노드에 대한 정보를 얻을 수 있다.
- 이를 이용해 알지 못하던 다른 노드를 받아들일 수 있으며, 장애도 감지할 수 있게 된다.
- 에포크는 클러스터에서 여러 이벤트의 순서를 나타내는 값이다.
- 분산 환경에서 각각의 노드는 에포크 값을 가지며, 이 값이 클수록 최신 구성을 갖고 있는 노드라는 것을 의미한다.
- 모든 노드는 끊임없이 PING/PONG을 주고받기 때문에 결국 모든 노드는 클러스터에서 가장 큰 구성 에포크 값으로 통일된다.
- 이 값은 클러스터 상태를 변경할 때와 페일오버가 발생할 때 동의를 구하기 위해 사용된다.
### 해시슬롯 구성이 전파되는 방법
- 클러스터에서 해시슬롯의 구성은 두 가지 방법으로 전파된다.
  - 하트비트 패킷 : 마스터 노드가 PING, PONG의 패킷을 보낼 때 항상 자기가 갖고 있는 해시슬롯을 패킷 데이터에 추가
  - 업데이트 메시지 : 하트비트 패킷에는 발신하는 노드의 구성 에포크 값이 포함돼 있으며, 패킷을 보낸 노드의 에포크 값이 오래됐다면 해당 패킷을 받은 노드는 신규 에포크의 구성 정보를 포함한 업데이트 메시지를 노드에 보내 하트비트 패킷을 보낸 노드의 해시슬롯 구성을 업데이트
- 클러스터가 시작됐을 때 우선 모든 노드의 해시슬롯은 NULL로 초기화된다.
```text
0 -> NULL
1 -> NULL
2 -> NULL
...
16383 -> NULL
```
- 만약 노드 A가 해시슬롯 1과 2를 갖고 있다고 주장하는 패킷을 수신했다고 해보자. 
- 이때 패킷의 구성 에포크가 3이었다면 이 패킷을 수신한 노드의 해시슬롯 테이블은 다음과 같이 변경된다.
```text
0 -> NULL
1 -> A [3]
2 -> A [3]
...
16383 -> NULL
```
- 만약 페일오버가 발생된 뒤 현재의 구성 에포크인 3보다 더 큰 4라는 구성 에포크를 가진 패킷을 수신했다고 해보자.
- 해당 패킷에서 노드 B가 해시슬롯 1, 2를 갖고 있다고 주장하고 있다면 하트비트 패킷을 수신한 노드는 해시슬롯 테이블을 다음과 같이 업데이트한다.
```text
0 -> NULL
1 -> B [4]
2 -> B [4]
```
- 해시슬롯 구성의 변경은 페일오버와 리샤딩 중에만 발생한다.
- 페일오버와 리샤딩하는 작업 모두 에포크가 증가하는 작업이기 때문에 작업 이후 변경사항을 클러스터 전체에 전파시킨다.
- 클러스터의 모든 노드는 가장 큰 구성 에포크 값을 가진 노드에 동의하기 때문에 클러스터 내의 모든 노드 값을 업데이트시킬 수 있다.
### 노드 핸드셰이크
- 한 노드가 클러스터에 합류하기 위해서는 `CLUSTER MEET` 커맨드를 다른 노드에 보낸다.
- 해당 커맨드를 수신한 노드는 자신이 알고 있는 다른 노드들에게 전파하고, 이 정보를 수신한 노드가 신규 합류한 노드를 모르는 상태라면 해당 노드와 `CLUSTER MEET`를 통해 신규연결을 맺게 된다.
- 이와 같은 방식으로 클러스터 내부의 모든 노드들은 풀 메쉬(full-mesh) 연결을 하게 된다.
### 클러스터 라이브 재구성
- 클러스터가 정상적으로 운영되는 동안 새로운 마스터 노드를 추가하거나 기존 마스터 노드를 제거할 수 있다.
- 클러스터에 새로운 노드를 추가하려면 빈 노드를 클러스터에 추가한 뒤, 일부 해시슬롯을 기존 마스터에서 신규 노드로 옮긴다.
- 클러스터에서 노드를 제거하려면 해당 노드를 빈 노드로 만들기 위해, 갖고 있던 해시슬롯을 다른 노드로 보낸다.
- A가 갖고 있던 해시슬롯 8을 B로 옮기고 싶다면 각 노드에서 다음과 같은 커맨드가 수행된다.
  - A에게 : CLUSTER SETSLOT 8 MIGRATING B
  - B에게 : CLUSTER SETSLOT 8 IMPORTING A
- 만약 위 커맨드가 실행중인 상태에서 노드 A가 해시슬롯 8에 대한 쿼리를 받았을 때 만약 기존에 존재하던 키를 읽는 쿼리라면 A에서 수행한다.
- 반대로 해시슬롯 8에 새로운 키를 생성하는 쿼리를 받았다면 이 쿼리는 B 노드로 리디렉션한다.
- 또한 레디스는 해시슬롯 8에 속한 키를 A에서 B로 마이그레이션한다.
```shell

CLUSTER GETKEYINSLOT slot count
```
- 이 커맨드는 지정한 해시슬롯이 가지고 있는 키를 반환하며, 반환된 모든 키에 대해 노드 A에 MIGRATE 커맨드를 전송한다.
- 다음 커맨드는 키를 원자적으로 A에서 B로 마이그레이션한다.
- 2개의 인스턴스 모두 키를 마이그레이션하는 동안 락이 걸리며, 이로 인한 경쟁 상황은 발생하지 않는다.
```shell

MIGRATE target-host target-port key target-database id timeout
```
- MIGRATE는 대상 인스턴스에 연결해서 키를 전송하고, OK 코드를 받으면 기존 데이터 셋에서 키를 삭제한다.
- 마이그레이션 프로세스가 완료되면 두 노드에게 모두 `SETSLOT slot> NODE <node-id>` 커맨드를 전송한다. 이 커맨드는 다른 모든 노드로 전파된다.
### 리디렉션
- 레디스 클러스터가 반환하는 리디렉션에는 `MOVED` 리디렉션과 `ASK`의 두 가지 종류가 있다.
- MOVED 리디렉션은 클라이언트에게 '요청하는 해시슬롯이 저 노드에 있으니 앞으로 이 키에 대한 요청은 저 노드로 보내'라는 것을 의미한다.
- ASK 리디렉션은 '지금 요청한 이 쿼리는 저 노드에서 수행해. 하지만 다음 노드는 다시 나한테 보내'라는 의미를 갖는다.
#### MOVE 리디렉션
- 레디스 노드는 클라이언트가 보낸 커맨드가 단일키 커맨드인지 혹은 다중키인 경우 언급된 여러 키가 모두 동일한 해시슬롯에 있는지 파악한 뒤 키가 속한 해시슬롯을 포함한 마스터 노드를 찾는다. 
- 만약 해당 커맨드를 받은 노드가 그 해시슬롯을 가지고 있을 경우 원하는 데이터를 해시슬롯에서 찾아 바로 반환할 수 있다.
- 아니라면 어떤 노드가 어떤 해시슬롯을 갖고 있는지 해시슬롯 맵을 확인한 후 MOVED 에러로 클라이언트에 응답한다.
```shell

GET X
-MOVED 2345 192.168.0.22:6379
```
- MOVED 에러는 키의 해시슬롯(2345)과 해당 해시슬롯을 갖고 있는 마스터 노드의 정보(192.168.0.22:6379)를 반환한다.
- 클라이언트는 반환받은 노드의 IP와 포트로 다시 커맨드를 수행해 데이터를 조회한다.
- 이때 클라이언트는 해시슬롯 2345가 192.168.0.22:6379 노드에 존재한다는 것을 기억한다.
- 이후 애플리케이션에서 이 키를 다시 조회하려고 할 경우, 클라이언트에서 바로 올바른 마스터 노드로 데이터를 조회할 수 있어 리디렉션 과정을 생략함으로써 시간을 단축할 수 있다.
#### ASK 리디렉션
- ASK 리디렉션은 해시슬롯이 이동되는 과정에서만 발생한다.
- 리디렉션 받은 클라이언트 동작
  - 리디렉션 오류가 반환한 노드 정보로 쿼리를 재전송하지만, 이후에 같은 키에 대한 쿼리가 들어오면 기존에 전송한 노드에 다시 보낸다.
  - 리디렉션을 받은 값으로 클라이언트의 해시슬롯 맵을 업데이트하지 않는다.
- A가 갖고 있던 해시슬롯 8을 B로 옮기는 과정
  - 해시슬롯을 옮기는 도중 클라이언트가 해시슬롯 8에 포함된 키인 user:1을 조회하려 한다.
  - 만약 클라이언트가 B 노드에 이 키값을 요청한다면 B는 리디렉션 요청을 보내는데, 이 때 MOVED가 아닌 ASK요청을 보낸다.
  - 마이그레이션 과정이 완료되면 8번 해시슬롯은 B로 이동될 예정이므로, 그 후의 요청은 B로 전송돼야 한다.
- 마이그레이션이 완료된 이후
  - 레디스는 ASK 리디렉션을 사용해 클라이언트의 연결을 A로 단 한번만 전환했다.
  - 클라이언트의 맵이 업데이트되지 않아서, 이후에 user:1을 조회하면 커맨드는 바로 B로 연결될 수 있다.
  - 만약 마이그레이션이 완료된 뒤 다른 클라이언트가 A에 user:1에 대한 커맨드를 수행하면 MOVED 리디렉션을 이용한다.
  - 해시슬롯을 소유하고 있는 노드가 완전히 B로 변경됐으므로, 클라이언트의 해시슬롯 맵을 업데이트해 다음 연결이 지속적으로 B로 이뤄지게하는 것이 적절하다.
### 장애 감지와 페일오버
- 레디스 클러스터에서는 대부분의 노드가 특정 노드에 접근할 수 없다는 것을 인지하면 해당 노드의 상태를 변경한다.
- PFAIL은 Possible failure, 즉 일부 노드에서는 해당 노드에 접근할 수 없지만, 아직 확실하진 않은 실패임을 의미한다.
- FAIL은 대다수의 노드에서 해당 노드에 장애가 발생했음을 동의한 상태임을 의미한다.
#### PFAIL 플래그
- 특정 노드에 NODE_TIMEOUT 시간이상 도달할 수 없는 경우 해당 노드에 대해 PFAIL 플래그로 표시한다.
- 노드에 도달할 수 없다는 것은 해당 노드에 PING 패킷을 보냈지만 NODE_TIMEOUT 시간보다 더 오랫동안 PONG을 받지 못한 상태를 의미한다.
#### FAIL 플래그
- 만약 A노드가 노드 B를 PFAIL 상태로 플래깅했다면 이후 클러스터 내의 다른 노드가 보낸 하트비트 패킷에서 B의 상태에 대한 정보를 듣는다.
- 이때 일정 시간내에 다른 노드에서 B에 대한 PFAIL 또는 FAIL 알림을 받으면 이 노드를 FAIL이라 플래깅한다.
### 복제본 선출
- 다음과 같은 조건에서 복제본은 페일오버를 직접 시도한다.
  - 마스터가 FAIL 상태다.
  - 마스터는 1개 이상의 해시슬롯을 갖고 있다.
  - 마스터와의 복제가 끊어진 지 오래다.
- 위의 조건을 모두 만족했을 때, 복제본은 마스터로 선출되기 위해 자신의 현재 에포크 값을 1 증가시키고, 마스터 인스턴스에 투표를 요청한다.
- 복제본은 클러스터의 모든 마스터 노드에 `FAILOVER_AUTH_REQUEST` 패킷을 보내 투표를 요청한다.
- 요청을 받은 마스터는 `FAILOVER_AUTH_ACK` 패킷으로 긍정적인 응답을 보내 투표에 동의함을 알린다.
- 이때 마스터는 동시에 다른 복제본을 승격시키는 것을 방지하기 위해 NODE_TIMEOUT*2시간 동안은 같은 마스터로 승격되고자 하는 다른 복제본에게는 투표할 수 없다.
- 응답을 받은 복제본은 현재 에포크 값보다 작은 에포크로 온 `AUTH_ACK`에 대한 응답은 무시하기 때문에, 이전 버전의 투표에 대한 응답은 거를 수 있다.
- 다수의 마스터로부터 ACK를 받은 복제본이 마스터 후보로 선출되며, NODE_TIMEOUT*2 시간동안 과반수 이상의 마스터에서 ACK가 오지 않으면 페일오버는 중단된다.