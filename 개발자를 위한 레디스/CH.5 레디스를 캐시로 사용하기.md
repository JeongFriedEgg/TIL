# CH.5 레디스를 캐시로 사용하기

## 레디스와 캐시
### 캐시란?
- 캐시란 데이터의 원본보다 더 빠르고 효율적으로 액세스할 수 있는 임시 데이터 저장소를 의미한다.
- 다음 조건을 만족시킨다면 캐시를 도입했을 때 성능을 효과적으로 개선할 수 있다.
  - 원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나, 매번 계산을 통해 데이터를 가져와야 한다. 
  - 캐시에서 데이터를 가져오는 것이 원본 데이터 저장소 데이터를 요청하는 것보다 빨라야 한다. 
  - 캐시에 저장된 데이터는 잘 변하지 않는 데이터다. 
  - 캐시에 저장된 데이터는 자주 검색되는 데이터다.
- 캐시는 데이터의 복제본을 저장하는 저장소이기 때문에 원본 데이터 저장소에서 데이터를 읽는 커넥션을 줄일 수 있다.
- 원본 데이터 저장소에서 데이터를 가져올 때 CPU와 메모리 등의 리소스를 많이 사용했다면 캐시를 사용함으로 애플리케이션 자체의 리소스를 줄일 수 있다.
### 캐시로서의 레디스
- 단순하게 키-값 형태로 저장하므로, 데이터를 저장하고 반환하는 것이 굉장히 간단하며, 자체적으로 다양한 자료구조를 제공하기 때문에 애플리케이션에서 사용하던 list, hash 등의 자료구조를 변환하는 과정 없이 레디스에 바로 저장할 수 있다.
- 레디스는 모든 데이터를 메모리에 저장하는 인메모리 데이터 저장소이기 때문에 데이터를 검색하고 반환하는 것이 상당히 빠르다는 특징을 갖고 있다.
- 레디스는 자체적으로 고가용성 기능을 가지고 있는 솔루션이라는 점도 큰 장점이다. 일부 캐싱 전략에서는 캐시에 접근할 수 없게 되면 이는 곧바로 서비스의 장애로 이어질 수도 있다.
- 레디스의 센티널 또는 클러스터 기능을 사용하면 마스터 노드의 장애를 자동으로 감지해 페일오버를 발생시키기 때문에 운영자의 개입 없이 캐시는 정상으로 유지될 수 있어 가용성이 높아진다.
- 레디스의 클러스터를 사용하면 캐시의 스케일 아웃 또한 쉽게 처리할 수 있다.
- 서비스의 규모에 따라 캐시 자체의 규모도 늘어나야 할 상황이 발생할 수 있는데, 자체 샤딩 솔루션인 클러스터를 사용하면 수평 확장이 굉장히 간단해진다는 장점이 존재한다.
### 캐싱 전략
#### 읽기 전략 - look aside
- 애플리케이션은 찾고자 하는 데이터가 먼저 캐시에 있는지를 확인한 뒤, 캐시에 데이터가 있으면 캐시에서 데이터를 읽어온다.(캐시 히트)
- 찾고자 하는 데이터가 없을 때에는 캐시 미스가 발생한다.
- 레디스로부터 데이터가 없다는 응답을 받은 애플리케이션은 직접 데이터베이스에 접근해 찾고자 하는 데이터를 가져온다. 그 뒤 애플리케이션은 이를 다시 캐시에 저장하는 과정을 거친다.
- 하지만 기존에 애플리케이션에서 레디스를 통해 데이터를 가져오는 연결이 매우 많았다면 모든 커넥션이 한꺼번에 원본 데이터베이스로 몰려 많은 부하를 발생시키고, 이로 인해 원본 데이터베이스의 응답이 느려지거나 리소스를 많이 차지하는 등의 이슈가 발생해 애플리케이션의 성능에 영향을 미칠 수 있다. 
- 찾고자 하는 데이터가 레디스에 없을 때에만 레디스에 데이터가 저장되기 때문에 이와 같은 구조는 lazy loading이라고도 부른다.
- 미리 데이터베이스에서 캐시로 데이터를 밀어넣어주는 작업을 하기도 하는데, 이를 캐시 워밍(cache warming)이라고도 한다.
#### 쓰기 전략과 캐시의 일관성
- 캐시는 데이터베이스에 저장돼 있는 데이터를 단순히 복사해 온 값이다. 따라서 원본 데이터와 동일한 값을 갖도록 유지하는 것이 필수적이다.
- 만약 데이터가 변경될 때 원본 데이터베이스에만 업데이트돼 캐시에는 변경된 값이 반영되지 않는다면 데이터 간 불일치가 일어난다.(캐시 불일치)
#### 1. write throught
- 데이터베이스에 업데이트할 때마다 매번 캐시에도 데이터를 함께 업데이트시키는 방식.
- 캐시는 항상 최신 데이터를 가지고 있을 수 있다는 장점이 있지만, 데이터는 매번 2개의 저장소에 저장돼야 하기 때문에 데이터를 쓸 때마다 시간이 많이 소요될 수 있다는 단점이 있다.
- 캐시는 다시 사용될만한 데이터가 저장되는 것이 좋다. 하지만 이 방식의 경우 다시 사용되지 않을 데이터일 수도 있는데, 무조건 캐시에도 저장되기 때문에 일종의 리소스 낭비가 발생할 수 있다고 볼 수 있다.
- 따라서 이 방식을 사용할 경우 데이터를 저장할 때 만료 시간을 사용할 것을 권장한다.
#### 2. cache invalidation
- 데이터베이스에 값을 업데이트할 때마다 캐시에서는 데이터를 삭제하는 전략이다.
#### 3. write behind (write back)
- 쓰기가 빈번하게 발생하는 서비스.
- 데이터베이스에 대량의 쓰기 작업이 발생하면 이는 많은 디스크 I/O를 유발해, 성능 저하가 발생할 수 있다.
- 따라서 먼저 데이터를 빠르게 접근할 수 있는 캐시에 업데이트한 뒤, 이후에는 건수나 특정 시간 간격 등에 따라 비동기적으로 데이터베이스에 업데이트하는 것이다.
- 저장되는 데이터가 실시간으로 정확한 데이터가 아니어도 되는 경우 이 방법이 유용할 수 있다.
- 좋아요를 누른 데이터를 우선 레디스에 저장해둔 다음 5분 간격으로 이를 집계해 데이터베이스에 저장하는 과정을 거친다면 데이터베이스의 성능을 향상시켜 애플리케이션의 성능도 향상시킬 수 있다.
## 캐시에서의 데이터 흐름
- 캐시는 가득차지 않게 일정 양의 데이터를 유지해야 하며 계속해서 새로운 데이터가 저장되고 기존 데이터는 삭제될 수 있도록 관리돼야 한다. 
- 따라서 캐시로 레디스를 사용할 때에는 데이터를 저장함과 동시에 적절한 시간의 TTL 값을 지정하는 것이 좋다.
### 만료 시간
- 레디스에서 만료시간, 즉 TTL(Time To Live)은 데이터가 얼마나 오래 저장될 것인지를 나타내는 시간 설정이다.
- 특정 키에 대한 만료시간이 설정되면 해당 키와 관련된 데이터는 지정된 시간이 지난 후에 레디스에서 자동으로 삭제된다.
- TTL 커맨드를 사용하면 키에 대한 만료시간을 확인할 수 있는데, 만료시간이 남아있다면 남은 시간을 반환하며, 키가 존재하지 않을 때에는 -2를, 키에 대해 만료시간이 지정되지 않았을 경우에는 -1을 반환한다.
```shell

> SET a 100
"OK"

> EXPIRE a 60
(integer) 1

> TTL a
(integer) 58
```
- INCR 커맨드로 데이터를 조작하거나 RENAME을 이용해 키의 이름을 바꾸더라도 설정된 만료시간은 변경되지 않는다.
```shell

> INCR a
(integer) 101

> TTL a
(integer) 51

> RENAME a apple
"OK"

> TTL apple
(integer) 41
```
- 그러나 기존 키에 새로운 값을 저장해 키를 덮어 쓸 때에는 이전에 설정한 만료시간은 유지되지 않고 사라진다.
```shell

> SET b 100
"OK"

> EXPIRE b 60
(integer) 1

> TTL b
(integer) 57

> SET b banana
"OK"

> TTL b
(integer) -1
```
### 메모리 관리와 maxmemory-policy 설정
- 레디스의 메모리는 제한적이기 때문에 모든 키에 만료시간을 설정하더라도 너무 많은 키가 저장되면 메모리가 가득차는 상황이 발생할 수 있다.
- 레디스에서는 데이터의 최대 저장용량을 설정하는 maxmemory 설정과 이 용량을 초과할 때의 처리방식을 결정하는 maxmemory-policy 설정값을 사용해 메모리를 관리한다.
#### Noeviction
- 기본값은 noeviction이다.
- 레디스에 데이터가 가득차더라도 임의로 데이터를 삭제하지 않고 더 이상 레디스에 데이터를 저장할 수 없다는 에러를 반환하는 설정 값이다.
- 하지만 캐시에 데이터를 저장하지 못해 에러가 발생할 경우 로직에 따라 장애 상황으로 이어질 수 있으며, 이런 상황에서는 관리자가 레디스의 데이터를 직접 지워야하기 때문에 레디스를 캐시로 사용할 때 권장하지 않는 설정값이다.
- 데이터의 관리를 캐시에게 맡기지 않고, 애플리케이션 측에서 관리하겠다는 것을 의미한다.
- 데이터가 가득 차더라도 캐시 내부적 판단으로 데이터를 삭제하는 것이 위험하다고 판단될 때 이 옵션을 사용할 수 있다.
#### LRU(Least-Recently Used) eviction
- 레디스에 데이터가 가득찼을 때 가장 최근에 사용되지 않은 데이터부터 삭제하는 정책이다.
- volatile-lru : 만료시간이 설정돼 있는 키에 한해서 LRU 방식으로 키를 삭제한다. 이미 만료시간이 설정돼 있는 키는 언젠가 삭제될 키라는 것을 의미하기 때문에, 이런 키 중 가장 오래 사용되지 않은 키를 삭제하는 방식이다. 만약 레디스 내부에 저장된 키에 모두 만료시간이 지정돼 있지 않다면 이는 noeviction 상황과 동일하다.
- allkeys-LRU : 이 방식은 모든 키에 대해 LRU 알고리즘을 이용해 데이터를 삭제하기 때문에 적어도 메모리가 꽉 찼을 때 장애가 발생할 상황은 방지할 수 있다.
#### LFU(Least-Frequently Used) eviction
- 레디스에 데이터가 가득찼을 때 가장 자주 사용 되지 않은 데이터부터 삭제하는 정책이다.
- 키가 오랫동안 사용되지 않았더라도 과거에 자주 액세스했던 키라면 나중에도 자주 사용될 수 있다는 가정하에 우선순위가 높아지게 된다.
- volatile-lfu : 만료시간이 설정돼 있는 키에 한해서 LFU 방식으로 키를 삭제한다.
- allkeys-lfu : 모든 키에 대해 LFU 알고리듬을 이용해 데이터를 삭제한다.
#### RANDOM eviction
- 레디스에 저장된 키 중 하나를 임의로 골라내 삭제한다.
- volatile-random : 만료시간이 설정돼 있는 키에 한해 랜덤하게 키를 삭제한다.
- allkeys-random : 모든 키에 대해 랜덤하게 키를 삭제한다.
#### volatile-ttl
- 만료시간이 가장 작은 키를 삭제한다.
- 삭제 예정시간이 얼마남지 않은 키를 추출해 해당 키를 미리 삭제하는 옵션이다.
### 캐시 스탬피드 현상
- 레디스에서 특정 키가 만료되는 시점을 생각해보자.
- 만약 여러 개의 애플리케이션에서 바라보던 키가 레디스에서 만료돼 삭제된다면 이 서버들은 한꺼번에 데이터베이스에 가서 데이터를 읽어오는 과정을 거친다. 이를 중복 읽기(duplicate read)라 한다.
- 이후 각 애플리케이션에서는 읽어온 데이터를 레디스에 쓰게 되는데, 이 또한 여러 번 반복되기 때문에 중복 쓰기(duplicate write)가 발생한다.
- 레디스에 데이터가 없다는 것을 인지한 여러 애플리케이션에서 동시에 데이터베이스에 접근해 무거운 쿼리를 실행하는 중복 읽기 작업은 데이터베이스에 부하를 줄 수 있으며, 이는 곧 서비스 이슈로도 이어질 수 있다.
#### 적절한 만료 시간 설정
- 캐시 스탬피드를 줄이기 위한 가장 간단한 방법은 만료시간을 너무 짧지 않게 설정하는 것이다.
#### 선 계산
```text
def fetch(key):
    value = redis.get(key)
    if (!value):
        value = db.fetch(key)
        redis.set(value)
    return value
```
- 만약 키가 실제로 만료되기 전에 이 값을 미리 갱신해준다면 여러 애플리케이션에서 한꺼번에 데이터베이스에 접근해 데이터를 읽어오는 과정을 줄여 불필요한 프로세스를 줄일 수 있다.
```text
def fetch(key, expiry_gap):
    ttl = redis.ttl(key)
    
    if ttl - (random() * expiry_gap) > 0:
        return redis.get(key)
    else:
        value = db.fetch(key)
        redis.set(value, KEY_TTL)
        return value
        
# Usage
fetch('hello', 2)
```
- 위의 함수를 이용하면 랜덤한 확률로 키가 만료되기 전 데이터를 갱신한다.
- 만약 random() 값이 6이었을 때 10-(6*2)는 0보다 작기 때문에 이 경우 애플리케이션은 데이터베이스에 접근해 데이터를 가지고 온 뒤 레디스의 값을 갱신한다.
- expiry_gap의 값을 적절히 설정해주는 것이 중요하다.
#### PER 알고리듬
- PER(Probabilistic Early Recomputation) 알고리즘이라고 부르는 이 알고리즘을 이용하면 캐시값이 만료되기 전에 언제 데이터베이스에 접근해서 값을 읽어오면 되는지 최적으로 계산할 수 있다.
```text
currentTime - ( timeToCompute * beta * log(rand()) ) > expiry
```
- currentTime : 현재 남은 만료시간
- timeToCompute : 캐시된 값을 다시 계산하는 데 걸리는 시간 
- beta : 기본적으로 1. 0보다 큰 값으로 설정 가능
- rand() : 0과 1 사이의 랜덤 값을 반환하는 함수
- expiry : 키를 재설정할 때 새로 넣어줄 만료 시간
- 만료 시간이 가까워질수록 currentTime과 expire 사이의 차이가 작아지며, rand() 함수가 반환한 무작위 값에 의존하기 때문에 조건이 참이 될 확률이 높아진다.
## 세션 스토어로서의 레디스
### 세션이란?
- 세션이란 서비스를 사용하는 클라이언트의 상태정보를 의미한다.
- 애플리케이션은 현재 서비스에 로그인돼 있는 클라이언트가 누구인지, 그 클라이언트가 어떤 활동을 하고 있는지 저장하고 있으며, 유저가 서비스를 떠나면 세션 스토어에서 유저의 정보를 삭제한다.
- 많은 서비스에서 레디스를 세션 스토어로 사용하고 있다.
- 유저가 로그인해 있는 동안에는 세션의 데이터를 끊임없이 읽고 쓰게 되므로 빠른 응답속도는 필수적이다.
### 세션 스토어가 필요한 이유
- 웹 서버를 늘리면 여러 개의 웹 서버에 트래픽을 분배할 수 있기 때문에 더 많은 유저를 수용할 수 있게 된다.
- 각 웹 서버별로 세션 스토어를 따로 관리한다면 유저는 유저의 세션 정보를 갖고 있는 웹 서버에 종속돼야 한다. 그렇지 않다면 유저 데이터 정합성에 문제가 생기기 때문이다.
- 쇼핑 카트에 분명히 아이템을 저장했는데, 서버에 재접속할 때마다 아이템이 사라졌다 생겼다 한다면 정상적인 서비스 이용이 불가능하다.
- 특정 웹 서버에 유저가 몰려 트래픽이 집중되는 상황이 발생하더라도 유저는 다른 서버를 사용할 수 없어, 결국 트래픽을 분산시킬 수 없는 상황이 발생된다. 이를 sticky session이라 한다.
- 유저의 세션 정보를 모든 웹 서버에 복제해서 저장하는 방법을 생각해볼 수 있다. 이를 all-to-all 방법이라 한다.
- 유저의 세션 데이터는 여러 서버로 복사돼 저장되기 때문에 불필요한 저장공간을 차지하게 된다.
- 하나의 유저는 한 번에 하나의 웹 서버에만 접속하기 때문에 다른 웹 서버에 저장된 유저의 세션 정보는 무의미하기 때문이다.
- 또한 데이터를 복제하는 과정에서 불필요한 네트워크 트래픽도 다수 발생하게 된다.
- 데이터베이스를 세션 스토어로 사용하는 방법.
- 만약 세션 스토어의 응답 속도가 느려지면 이는 곧바로 클라이언트의 응답속도 저하로 이어질 수 있다.
- 레디스를 세션 스토어로 사용해 서버, 데이터베이스와 분리시켜 놓은 뒤 여러 서버에서 세션 스토어를 바라보도록 구성한다면 앞선 모든 이슈를 해결할 수 있다.
- 유저는 세션 스토어에 구애받지 않고 어떤 웹 서버에 연결되더라도 동일한 세션 데이터를 조회할 수 있어 트래픽을 효율적으로 분산시킬 수 있으며, 데이터의 일관성도 고려할 필요가 없다.
```shell

> HMSET usersession:1 Name Garimoo IP 10:20:104:30 Hits 1
OK

> HINCRBY usersession:1 Hits 1
1) "2"
```
### 캐시와 세션의 차이
- 캐시에 저장된 데이터는 여러 애플리케이션에서 함께 사용할 수 있다.
- 여러 애플리케이션이 함께 사용할수록 더 효율적이다. 하지만 세션 스토어에 저장된 데이터는 여러 사용자 간 공유되지 않으며, 특정 사용자 ID에 한해 유효하다.
- 유저가 로그인해 있는 동안, 즉 세션이 활성화돼 있는 동안에는 애플리케이션은 유저의 데이터를 데이터베이스가 아닌 세션 스토어에만 저장한다.
- 예를 들어 유저가 최근 봤던 아이템, 혹은 장바구니에 담긴 아이템은 세션 스토어에만 담겨있다. 유저가 로그아웃할 때 세션은 종료되며 이때 데이터의 종류에 따라 데이터베이스에 저장해 영구적으로 보관할 것인지, 삭제할 것인지가 결정된다.
- 세션 스토어가 가지고 있는 데이터는 유일할 수 있다. 이때 세션 스토어에 장애가 발생하면 내부 데이터가 손실될 가능성이 있으므로 레디스를 세션 스토어로 활용할 때에는 레디스를 캐시로 사용할 때보다 더 신중한 운영이 필요하다.