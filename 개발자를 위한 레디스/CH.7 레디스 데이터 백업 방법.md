# CH.7 레디스 데이터 백업 방법

## 레디스에서 데이터를 영구 저장하기
- 레디스를 복제 구조로 사용할 경우 데이터가 실시간으로 복제본에 전달되고 있으니 따로 데이터를 백업할 필요를 느끼지 못할수도 있다. 하지만 백업과 복제는 목적부터 다르다는 점에 유의하자.
- 복제는 가용성을 위한 것이며, 백업은 장애 상황에서 데이터의 복구를 위해 필요하다.
- 레디스를 캐시가 아닌 영구 저장소와 같은 용도로 사용한다면 디스크에 데이터를 주기적으로 백업하는 것이 안전하다.
- AOF(Append Only File) : 레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록. 복원시에는 파일을 다시 읽어가며 데이터 세트 재구성.
- RDB(Redis DataBase) : 일정 시점에 메모리에 저장된 데이터 전체를 저장(snapshot 방식)
```shell

> SET keyl a
OK
> SET key1 apple
OK
> SET key2 b
OK
> DEL key2
(integer) 1
```

```text
AOF

set key1 a
set key1 apple
set key2 b
del key2
```
```text
RDB

key1 -> apple
```
- key1의 데이터가 다른 값으로 변경된 내역, key2가 생성됐다가 삭제된 내역 모두 AOF 파일에 기록된다.
- 따라서 AOF 파일을 처음부터 끝까지 따라가면 원본 데이터에 도달할 수 있게 된다.
- RDB 파일에는 실제로 메모리에 저장된 값인 key1의 값이 apple이라는 데이터만 남아있게 된다.
- RDB 파일의 경우, 시점 단위로 여러 백업본을 저장할 수 있고 AOF 파일보다 복원이 빠르다는 장점이 있지만 특정 시점으로의 복구는 불가능하다.
- AOF는 RDB 파일보다 크기가 크고 주기적으로 압축해 재작성해야 하지만, 원하는 시점으로 복구할 수 있다는 장점이 있다.
- 하나의 인스턴스에서 RDB와 AOF 옵션을 동시에 사용하는 것도 가능하며, 일반적인 RDB만큼의 데이터 안정성을 원하는 경우 두 가지 백업 방식을 동시에 사용하기를 권장한다.
- 레디스 서버는 재시작될 때 AOF 파일이나 RDB 파일이 존재하는지 확인한 뒤, 파일이 있을 때에는 파일을 로드한다.
- 레디스는 RDB 파일보다 AOF 파일이 더 내구성이 보장된다고 판단하기 때문에 2개의 파일이 모두 존재할 때에는 AOF의 데이터를 로드한다.
## RDB 방식의 데이터 백업
- 원하는 시점에 메모리 자체를 스냅숏 찍듯 저장할 수 있기 때문에 백업에 적합한 파일 형태라고 볼 수 있다.
- 예를 들어 한 시간에 한 번씩 RDB 파일을 생성할 수 있으며, 장애발생시 원하는 시점으로 데이터를 복원할 수 있다.
- RDB 파일을 생성할 수 있는 방법
  - 설정 파일에서 특정 조건에 파일이 자동으로 저장되도록 지정할 수 있다.
  - 사용자가 원하는 시점에 커맨드를 이용해 수동으로 파일을 생성할 수 있다.
  - 복제 기능을 사용한다면 레디스는 자동으로 RDB 파일을 생성한다.
### 특정 조건에 자동으로 RDB 파일 생성
```shell

save <기간(초)><기간 내 변경된 키의 개수>
dbfilename <RDB 파일 이름>
dir <RDB 파일이 저장될 경로>
```
- 일정한 기간(초) 동안 변경된 키의 개수가 조건에 맞을 때 레디스 서버는 자동으로 RDB 파일을 저장한다.
```shell

save 900 1
save 300 10
save 60 10000
```
- redis.conf에 위와 같은 조건으로 save 옵션을 설정한다면 인스턴스는 다음과 같은 상황에서 RDB 파일을 생성한다.
  - 900초(15분) 동안 1개 이상의 키가 변경된 경우
  - 300초(5분) 동안 10개 이상의 키가 변경된 경우
  - 60초(1분) 동안 10,000개 이상의 키가 변경된 경우
```shell

# 현재 적용된 save 옵션 확인
> CONFIG GET save
1) "save"
2) "900 1 300 10 60 10000"

# save 옵션 초기화
> CONFIG SET save ""
OK

# 현재 적용된 save 옵션 확인
> CONFIG GET save
1) "save"
2) ""

# redis.conf 파일 재작성
> CONFIG REWRITE
OK
```
### 수동으로 RDB 파일 생성
- `SAVE`, `BGSAVE` 커맨드를 이용하면 원하는 시점에 직접 RDB 파일을 생성할 수 있다.
- `SAVE`는 동기 방식으로 파일을 저장한다. SAVE 커맨드를 실행하면 파일 생성이 완료될 때까지 다른 모든 클라이언트의 명령을 차단한다.
- `BGSAVE`는 fork를 호출해 자식 프로세스를 생성하며 생성된 자식 프로세스가 백그라운드에서 RDB 파일을 생성한 뒤 종료된다.
- 레디스를 이용하는 다른 클라이언트는 원래대로 부모 프로세스를 이용해서 처리되기 때문에 파일 저장에는 영향을 받지 않는다.
- 만약 이미 백그라운드로 데이터가 저장되고 있을 때 이 커맨드를 수행하면 에러를 반환한다. 이런 상황에서는 `BGSAVE`와 함께 `SCHEDULE` 옵션을 사용할 수 있는데, 이미 파일이 백그라운드에서 저장중일 때 이 커맨드를 입력받은 레디스는 일단 OK를 반환한 뒤, 기존에 진행 중이던 백업이 완료됐을 때 다시 BGSAVE를 실행한다.
### 복제를 사용할 경우 자동으로 RDB 파일 생성
- 복제본에서 REPLICAOF 커맨드를 이용해 복제를 요청하면 마스터 노드에서는 RDB 파일을 새로 생성해 복제본에 전달한다.
- 이미 복제 연결이 돼있는 상태에서 네트워크 등의 이슈로 인해 일정시간이상 복제가 끊어졌다가 복구된 경우 복제 재연결이 발생하며, 이럴 경우에도 마스터 노드는 복제본으로 RDB 파일을 전송한다.
## AOF 방식의 데이터 백업
- AOF는 레디스 인스턴스에서 수행된 모든 쓰기 작업의 로그를 차례로 기록한다.
- 실수로 FLUSHALL 커맨드로 데이터를 모두 날려버렸다 해도, AOF 파일을 직접 열어 FLUSHALL 커맨드만 삭제한 뒤 레디스를 재시작시킨다면 커맨드를 실행하기 직전까지로 데이터를 바로 복구할 수 있다. 
- 설정 파일에서 `appendonly` 옵션을 yes로 지정하면 AOF 파일에 주기적으로 데이터가 저장된다. AOF 파일은 `appenddirname`에서 지정한 경로와 `appendfilename` 옵션에 설정한 이름으로 생성된다.
```shell

appendonly yes
appendfilename "appendonly.aof"
appenddirname "appendonlydir"
```
```shell

> SET key1 apple
OK
> SET key1 beer
OK
> DEL keyl
(integer) 1
> DEL non_existing_key
(integer) 0
```
- AOF 파일에는 메모리상의 데이터가 변경되는 커맨드만 기록되기 때문에 마지막의 `DEL non_existing_key` 작업은 기록되지 않는다.
- AOF에서 모든 커맨드의 실행 내역은 다음과 같이 레디스 프로토콜 RESP 형식으로 저장된다.
```shell

*3
$3
set
$4
key1
$5
apple
*3
$3
set
$4
key1
$4
beer
*2
$3
del
$4
key1
```
- 하지만 항상 AOF 파일이 사용자가 실행한 커맨드를 그대로 저장하는 것은 아니다.
- list에서 블로킹 기능을 지원하는 BRPOP 커맨드는 AOF 파일에 저장될 때에는 RPOP로 기록된다.
- AOF 파일에서 블로킹 기능을 굳이 명시해줄 필요는 없기 때문이다.
```shell

> RPUSH mylist a bc d e
(integer) 5

> BRPOP mylist 1
1) "mylist"
2) "e"
```
```shell

*7
$5
RPUSH
$6
mylist
$1
a
$1
b
$1
c
$1
d
$1
e
*2
$4
RPOP
$6
mylist
```
- string 값에 사용자가 입력한 부동소수점 값을 더해주는 `INCRBYFLOAT` 커맨드도 AOF 파일에는 그대로 기록되지 않는다.
```shell

> SET counter 100
OK
> INCRBYFLOAT counter 50
"150"
```
- 레디스가 실행되는 아키텍처에 따라 부동소수점을 처리하는 방식이 다를 수 있기 때문에 AOF 파일에는 증분 후의 값을 직접 SET하는 커맨드로 변경돼 저장된다.
```shell

*3
$3
SET
$7
counter
$3
100
*4
$3
SET
$7
counter
$3
150
$7
KEEPTTL
```
### AOF 파일을 재구성하는 방법
- AOF 파일을 이용한 백업 기능을 안정적으로 사용하려면 점점 커지는 파일을 주기적으로 압축시키는 재구성(rewrite) 작업이 필요하다.
- RDB에서와 마찬가지로 특정 조건에 자동으로 재구성되도록 설정할 수도 있으며, 사용자가 원하는 시점에 커맨드를 이용해 재구성시킬 수 있다.
- 재구성은 기존 디스크에 저장됐던 AOF 파일을 사용하는 것이 아니라 레디스 메모리에 있는 데이터를 읽어와서 새로운 파일로 저장하는 형태로 동작한다.
```text

RDB file (binary)         고정 영역
----------------------------------
AOF tail (RESP 프로토콜)    증분 영역
```
- AOF 파일의 앞부분은 메모리의 데이터를 읽어와 바이너리 형태로 저장한 RDB 파일이 위치한다.
- 이후 레디스의 메모리를 변경한 커맨드 로그들은 RESP 형태로 RDB 파일의 뒤에 쌓이는 형태로 (append only하게) 증가한다.
- 버전 7 이전까지 AOF 파일의 재구성 과정
  1. 레디스는 fork를 이용해 자식 프로세스를 생성한다. 생성된 자식 프로세스는 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장한다.
  2. 백그라운드로 (1)의 과정이 진행되는 동안 레디스 메모리의 데이터가 변경된 내역은 기존의 AOF 파일과 인메모리 버퍼에 동시에 저장된다.
  3. (1)의 AOF 재구성 과정이 끝나면 인메모리 버퍼에 저장된 내용을 (1)의 임시 파일 마지막에 추가한다.
  4. 생성된 임시 파일로 기존 AOF 파일을 덮어 씌운다.
- (2)의 과정에서 RDB 파일이 저장되는 동안 데이터가 변경된 동일한 로그가 AOF 파일과 인메모리 버퍼에 이중으로 저장된다.
- 또한 하나의 AOF 파일 내에 바이너리 형태와 RESP의 텍스트 형태의 데이터가 함께 저장돼 수동으로 AOF 파일을 처리할 때 관리가 복잡할 수 있다는 단점이 존재한다.
- 버전 7 이후에서 AOF는 기본이 되는 바이너리 형태의 RDB 파일, 증가하는 RESP의 텍스트 형태의 AOF 파일로 나눠서 데이터를 관리한다.
- 또한 현재 레디스가 바라보고 있는 파일이 어떤 것인지 나타내는 매니페스트 파일을 추가적으로 도입했으며, 매니페스트 파일은 RDB와 AOF 파일이 어떤 것인지 알려주는 역할을 한다.
- 버전 7 이후에서 AOF 재구성
  1. 레디스 인스턴스는 fork를 이용해 자식 프로세스를 생성한다. 생성된 자식 프로세스는 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장한다.
  2. 백그라운드로 (1)의 과정이 진행되는 동안 레디스 메모리의 데이터가 변경된 내역은 신규 AOF 파일에 저장된다.
  3. (1)의 AOF 재구성 과정이 끝나면 임시 매니페스트 파일을 생성한 뒤, 변경된 버전으로 매니페스트 파일 내용을 업데이트한다.
  4. 생성된 임시 매니페스트 파일로 기존 매니페스트 파일을 덮어씌운 뒤, 이전 버전의 AOF, RDB 파일들을 삭제한다.
### 자동 AOF 재구성
```shell

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```
- `auto-aof-rewrite-percentage`는 AOF 파일을 다시 쓰기위한 시점을 정하기 위한 옵션이다.
- 마지막으로 재구성됐던 AOF 파일의 크기와 비교해, 현재의 AOF 파일이 지정된 퍼센트만큼 커졌을 때 재구성을 시도한다.
- 마지막으로 저장된 AOF 파일의 크기는 레디스에서 INFO Persistence 커맨드로 확인할 수 있는 `aof_base_size` 값이다.
```shell

> INFO Persistence
# Persistence
...
aof_current_size:186830
aof_base_size:145802
...
```
- 현재의 `aof_base_size`는 145802이고, `aof_current_size`는 186830이다.
- `auto-aof-rewrite-percentage`가 100이라면 `aof_current_size`가 `aof_base_size`의 100%만큼 커진 291604가 되면 자동으로 재구성을 시도한다.
- `auto-aof-rewrite-min-size` 옵션은 재구성된 이후의 AOF 파일의 최소 크기를 지정할 수 있다. 사용자가 데이터를 생성하고 삭제하는 작업을 반복했다고 생각해보자.
- 실제로 재구성 시도해 새로 저장된 RDB 파일의 크기, 즉 `aof_base_size`가 1KB로 줄어드는 경우가 발생할 수 있다.
- 이 경우 `aof_current_size`가 1KB의 100%에 도달할 때마다 재구성을 시도해야 하는 상황이 발생할 수 있으며, 이는 비효율적인 작업을 트리거할 수 있다.
- 따라서 마지막으로 작성된 AOF 파일 크기를 기준으로 재구성하되, 적어도 AOF 파일이 특정 크기이상일 때에만 재구성를 하도록 지정해 비효율적인 작업을 최소화할 수 있다.
### 수동 AOF 재구성
- `BGREWRITEAOF` 커맨드를 이용하면 원하는 시점에 직접 AOF 파일을 재구성할 수 있다.
### AOF 타임스탬프
- 버전 7 이상부터는 AOF를 저장할 때 타임스탬프를 남길 수 있다.
```shell

aof-timestamp-enabled no
```
- 설정 파일에서 `aof-timestamp-enabled` 옵션을 활성화시키면 다음과 같이 AOF 데이터가 저장될 때 타임스탬프도 함께 저장된다.
```shell

#TS: 1669532240
*2
$6
SELECT
$1
0
*3
$3
set
$1
a
$1
b
```
- 이를 이용하면 수동으로 AOF 파일을 조작하지 않아도 시스템상에서 시점 복원(point-in-lime recovery)이 가능하다.
```shell

#TS:1669532240
*2
$6
SELECT
$1
0
*3
$3
set
$1
a
$1
b
*2
$6
SELECT
$1
#TS: 1669532845
*1
$8
flushall
```
- 레디스에서 제공하는 redis-check-aof 프로그램을 사용해 FLUSHALL이 실행되기 전까지로 데이터를 복구할 수 있다.
### AOF 파일 복원
- 시점 복원(point-in-time recovery)에서 사용한 redis-check-aof 프로그램은 AOF 파일이 손상됐을 때에도 사용할 수 있다.
- 의도치 않은 서버의 장애발생시 AOF 파일 작성도 중 레디스가 중지됐을 가능성이 존재한다.
- 레디스가 의도치 않은 장애로 중단됐을 때 redis-check-aof 프로그램을 사용하면 AOF 파일의 상태가 정상적인지 확인할 수 있다.
### AOF 파일의 안전성
- 운영체제에서 애플리케이션이 파일에 데이터를 저장하고자 할 때, 곧바로 디스크에 데이터가 저장되진 않는다.
- `WRITE`라는 시스템 콜을 이용해 애플리케이션에서 파일에 데이터를 저장하겠다 하면 데이터는 커널 영역의 OS 버퍼에 임시로 저장한다.
- 운영체제가 판단하기에 커널이 여유있거나, 최대지연시간인 30초에 도달하면 커널 버퍼의 데이터를 실제로 디스크에 내려쓴다.
- `FSYNC`는 커널의 OS 버퍼에 저장된 내용을 실제로 디스크에 내리도록 강제하는 시스템 콜이다.
- OS에 부하가 있더라도 FSYNC가 호출되면 데이터는 무조건 디스크에 플러시된다.
- `APPENDFSYNC no` : AOF 데이터를 저장할 때 WRITE 시스템 콜을 호출한다. 데이터는 커널 영역에 데이터가 잘 저장되는지만 확인하기 때문에 쓰기성능이 가장 빠르다.
- `APPENDFSYNC always` : AOF 데이터를 저장할 때 항상 WRITE와 FSYNC 시스템 콜을 함께 호출한다. 즉, 매번 쓰고자 하는 데이터가 파일에 정확하게 저장되는 것을 기다리기 때문에 쓰기 성능은 가장 느리다.
- `APPENDFSYNC everysec` : 데이터를 저장할 때 WRITE 시스템 콜을 호출하며, 1초에 한 번씩 FSYNC 시스템 콜을 호출한다. 성능은 no 옵션을 사용했을 때와 거의 비슷하다.
## 백업을 사용할 때 주의할 점
- RDB와 AOF 파일을 사용하는 경우 인스턴스의 maxmemory 값은 실제 서버 메모리보다 여유를 갖고 설정하는 것이 좋다.
- 레디스는 Copy-On-Write(COW) 방식을 이용해 메모리상의 데이터를 하나 더 복사하는 방법을 이용해 백업을 진행하면서도 클라이언트의 요청사항을 받아 메모리의 데이터를 읽고 수정하는 작업을 진행할 수 있다.
- 물리적 메모리에 있는 실제 메모리 페이지가 그대로 복제되기 때문에 최악의 경우 레디스는 기존 메모리 용량의 2배를 사용하게 될 수도 있다.
- 레디스의 maxmemory 값을 너무 크게 설정한 경우, 레디스의 copy-on-write 동작으로 인해 OS 메모리가 가득차는 상황이 발생할 수 있으며, 이로 인해 OOM(out of Memory)문제로 서버가 다운될 수 있다.
- 따라서 레디스의 maxmemory 옵션은 실제 메모리보다 여유를 갖고 설정하는 것이 안정적이다