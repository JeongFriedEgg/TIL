# CH.1 마이크로서비스 아키텍처와 레디스

### 데이터 저장소 요구 사항의 변화
- 최근의 서비스에서 정해진 형태가 없고, 크기와 구조를 예측할 수 없는 비정형 데이터가 증가하고 있다. -> 그래프화된 데이터, 실시간 로그 데이터(시계열 데이터), JSON 데이터(다양한 필드를 포함함)
- NoSQL을 사용할 경우 개발팀이 바로 데이터 구조를 바꿀 수 있어 더 빠른 개발이 가능하다.

### NoSQL이란?
- 관계가 정의돼 있지 않은 데이터를 저장한다는 특징이 있다.
- 기존의 관계형 데이터베이스의 한계를 넘어서기 위해 새로 고안된 데이터베이스인 만큼, 마이크로서비스의 저장소로 쓰일 수 있도록 여러 요구사항을 만족시킨다.

#### 확장성
- 예상치 못한 이벤트로 인한 트랜잭션의 증가에 유연하게 확장할 수 있다.

#### 고가용성
- 데이터 저장소를 사용할 수 없는 상황은 곧 서비스의 장애로 이어진다.
- 데이터 저장소는 장애 상황에서 신속하게 복구돼 항상 사용할 수 있는 상태를 유지해야 한다.

#### 클라우드 네이티브
- 클라우드 제공 업체에서 제공하는 DBaas를 사용하면 직접 설치, 운영할 필요 없이, 설치된 상품을 바로 사용할 수 있게 된다.

#### 단순성
- 한 가지의 데이터 모델이 모든 서비스에 최적화되진 않기 때문에 서비스별로 적절한 데이터 모델 즉, 멀티 모델 데이터베이스를 사용하길 원한다.

#### 유연성
- 비정형 데이터가 급속하게 많아졌기 때문에 이러한 데이터를 적합한 형식으로 저장할 수 있는 데이터 저장소가 필요해졌다.

### NoSQL 데이터 저장소 유형

#### 그래프 유형
- 엔티티 간의 관계를 효율적으로 저장하도록 설계됐다.
- 관계를 저장하고 표현할 때 유용하게 사용될 수 있으며, 저장되는 속성의 크기가 크거나 혹은 매우 많은 속성을 저장할 때에는 적합하지 않은 경우가 많다.
- 추천 서비스에서 유용하게 사용될 수 있다. SNS에서 유저(노드)간 친구 관계(에지)를 이용해 새로운 친구를 추천해주는 서비스를 구현할 수 있으며, 쇼핑몰에서 관심 분야나 구매 이력이 비슷한 다른 유저가 구입한 제품을 파악해 관심이 있어 할만한 상품을 추천해줄 수 있는 기능 또한 쉽게 구현할 수 있다.

#### 칼럼 유형
- 테이블을 행이 아닌 열을 기준으로 저장한다는 철학으로 설계됐다.

#### 문서 유형
- JSON 형태로 데이터가 저장돼, 개발자들이 편하게 사용할 수 있는 구조다.
- 스키마가 따로 정해져있지 않기 때문에 애플리케이션에 맞게 데이터를 그대로 저장할 수 있어 유연성이 크다는 장점이 존재한다.
- 이 유형에서는 모든 값은 항상 키와 연결되는 계층적 트리와 같은 구조를 갖는다.
- 데이터를 저장하거나 검색하는 데 효과적이다.
- MongoDB, CouchDB, AWS의 DocumentDB 등이 있다.

#### 키-값 유형
- 가장 단순하고 빠르다.
- 키 자체도 유의미한 데이터다.
- 키를 사용해 값을 검색할 수 있으며, 키를 삭제하면 값도 삭제된다.
- 이 유형의 데이터베이스는 데이터의 저장이 간단하기 때문에 다른 유형보다 수평적 확장이 쉽다.
- 게임이나 IoT와 같은 실시간 서비스에서는 사용자의 경험을 위해 빠른 응답속도가 중요하다.
- 특히 로그를 남기는 작업이나 대규모 세션을 실시간으로 관리해야 하는 상황에서는 지연 시간을 최소화해야 한다.
- 이와 같은 환경에서 키-값 유형의 데이터 모델은 그 구조의 단순성으로 인해 빠른 데이터 액세스와 처리속도를 보장해준다.

### 레디스란?
- Remote dictionary server의 약자인 레디스(Redis)는 고성능 키-값 유형의 인메모리(in-memory) NoSQL 데이터베이스이다.

#### 레디스의 특징
- 실시간 응답(빠른 성능)
  - 온디스크 형태의 데이터베이스에서 데이터는 영구적으로 디스크에 저장된다.
  - 자주 사용되는 데이터는 캐싱돼 메모리에 올라와 있는 경우도 있지만, 그렇지 않은 데이터를 찾고자 할 때에는 직접 디스크에 가서 데이터를 검색하는 과정을 거쳐야 한다.
  - 페이지 단위로 메모리에 올린 뒤 메모리에서 데이터를 찾고, 없는 경우 다시 다른 페이지를 디스크에서 가져와 메모리에 올린 뒤 찾는 과정을 반복한다.
  - HDD와 SSD와 같은 디스크에 접근하는 속도는 RAM과 같은 메모리에 접근하는 속도보다 현저히 느리다.
  - 인메모리 형태의 데이터베이스에서는 모든 데이터가 컴퓨터의 메모리에서 관리된다.
  - 디스크에 접근하는 과정이 필요없기 때문에 데이터의 처리성능이 굉장히 빠르다.
- 단순성
  - 키에 매핑되는 값에는 문자열 뿐만 아니라 해시(hash), 셋(set) 등 더욱 복잡하고 다양한 데이터 구조를 저장할 수 있도록 지원한다.
  - 임피던스 불일치(impedance mismatches)란 기존 관계형 데이터베이스의 테이블과 프로그래밍 언어간 데이터 구조, 기능의 차이로 인해 발생하는 충돌을 의미한다.
  - 레디스는 내장된 다양한 자료 구조를 통해 임피던스 불일치를 해소하고 개발을 편리하게 할 수 있도록 지원한다.
  - <span style="color:#00ff00">레디스는 싱글 스레드로 동작한다. 정확히 말하자면 메인 스레드 1개와 별도의 스레드 3개, 총 4개의 스레드로 동작한다.</span>
  - <span style="color:#00ff00">클라이언트의 커맨드를 처리하는 부분은 이벤트 루프를 이용한 싱글 스레드로 동작한다.</span>
  - 최소 하나의 코어만 있어도 레디스를 사용할 수 있어 배포가 쉬우며, CPU가 적은 서버에서도 좋은 성능을 낼 수 있다.
  - 멀티스레드 애플리케이션에서 요구되는 동기화나 잠금 메커니즘 없이도 안정적이고 빠르게 사용자의 요청을 처리할 수 있다.
  - 레디스가 싱글 스레드로 동작한다는 것은 한 사용자가 오래 걸리는 커맨드를 수행한다면, 다른 사용자는 그 쿼리가 완료될 때까지 대기할 수밖에 없다는 것이다. 이러한 특징으로 인해 인적 장애가 발생할 가능성이 매우 높다. 
- 고가용성
  - 복제를 통해 데이터를 여러 서버에 분산시킬 수 있으며, 센티널(Sentinel)은 장애 상황을 탐지해 자동으로 페일오버(fail-over)를 시켜준다.
  - 센티널을 이용해 레디스에 연결하는 구조에서는 마스터에 장애가 발생하더라도 레디스로의 엔드포인트를 변경할 필요 없이 페일오버가 완료돼 정상화된 마스터 노드를 사용할 수 있다.
- 확장성
  - 레디스 클러스터 내에서 자동으로 샤딩된 후 저장되며, 여러 개의 복제본이 생성될 수 있다.
  - 이 데이터의 분리는 데이터베이스 레이어에서 처리되며 어플리케이션에서는 대상 데이터가 어떤 샤드에 있는지 신경쓰지 않아도 되므로, 레디스를 사용할 때와 동일하게 데이터를 가져오고 저장할 수 있다.
  - 클러스터 구조에서 모든 레디스 인스턴스는 클러스터 버스라는 프로토콜을 이용해 서로 감시하고 있으며, 이를 이용해 클러스터의 마스터 노드에 문제가 발생하면 자동으로 페일오버를 시켜 고가용성을 유지할 수 있다.
- 클라우드 네이티브 - 멀티 클라우드
  - 멀티 클라우드는 여러 클라우드 제공업체의 서비스를 동시에 혹은 혼합해 활용하는 전략을 의미한다.
  - 멀티 클라우드를 사용하면 데이터가 특정 지역이나 국가 내에 물리적으로 위치하도록 조절할 수 있어, 더 가까운 저장소에서 데이터를 처리하게 되므로 대기 시간을 줄이고 장애 상황에 더욱 강건하게 대응할 수 있다.

### 마이크로서비스 아키텍처와 레디스

#### 데이터 저장소로서의 레디스
- <span style="color:#00ff00">메모리에 있는 데이터가 영구 저장되지 않기 때문에 데이터 저장소로 사용하기 위해 레디스의 도입을 고민할 때 데이터의 영속성을 고민할 수 있으나, 레디스의 데이터는 AOF(Append Only File)와 RDB(Redis DataBase) 형식으로 디스크에 주기적으로 저장할 수 있다.</span>

#### 메시지 브로커로서의 레디스
- 레디스의 pub/sub 기능은 가장 간단한 메시징 기능으로, 굉장히 빠르게 동작하며 간단하게 사용할 수 있다.
- 1개의 채널에 데이터를 던지면 이 채널을 듣고 있는 모든 소비자는 데이터를 빠르게 가져갈 수 있다.
- pub/sub에서 모든 데이터는 전달된 뒤 삭제되는 일회성으로, 모든 메시징 상황에 적합하진 않지만 fire-and-forget 패턴이 필요한 간단한 알림(notification) 서비스에서는 유용하게 사용할 수 있다.
- 레디스의 list 자료 구조는 메시징 큐로 사용하기 알맞다.
- 어플리케이션은 list에 데이터가 있는지 매번 확인할 필요 없이 대기하다가 list에 새로운 데이터가 들어오면 읽어갈 수 있는 블로킹 기능을 사용할 수도 있다.
- 레디스의 stream 자료 구조를 이용하면 레디스를 완벽한 스트림 플랫폼으로 사용할 수 있다.
- stream은 아파치 카프카 시스템에서 영감을 받아 만들어진 자료 구조로, 데이터는 계속해서 추가되는 방식으로 저장된다(append-only).