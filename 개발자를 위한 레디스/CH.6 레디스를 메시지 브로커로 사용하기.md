# CH.6 레디스를 메시지 브로커로 사용하기
- 모듈 간의 통신에서는 되도록 비동기 통신(async)을 사용하는 것을 권장 하며, 동기 통신(sync)의 횟수를 최대한 줄이는 것이 바람직하다.

## 메시징 큐와 이벤트 스트림
- 메시징 큐에서는 주로 데이터를 생성하는 쪽을 생산자(Producer)로, 데이터를 수신하는 쪽을 소비자(Consumer)로 지칭한다.
- 이벤트 스트림에서는 데이터를 생성하는 쪽을 발행자(Publisher)로, 데이터를 조회하는 쪽을 구독자(Subscriber)로 지칭한다.
- 두 가지 차이점
  - 첫 번째는 방향성이다. 메시징 큐의 생산자는 소비자의 큐로 데이터를 직접 푸시한다. 2개의 서비스에 같은 메시지를 보내야 할 때 메시징 큐를 이용한다면 생산자는 2개의 각각 다른 메시징 큐에 각각 데이터를 푸시(push) 해야 한다.
  - 반면 스트림을 이용한다면 생산자는 스트림의 특정 저장소에 하나의 메시지를 보낼 수 있고, 메시지를 읽어가고자 하는 소비자들은 스트림에서 같은 메시지를 풀(pull)해 갈 수 있기 때문에 메시지를 복제해서 저장하지 않아도 된다.
  - 두 번째는 데이터의 영속성이다. 메시징 큐에서는 소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제한다.
  - 하지만 이벤트 스트림에서 구독자가 읽어간 데이터는 바로 삭제되지 않고, 저장소의 설정에 따라 특정 기간동안 저장될 수 있다.
### 레디스를 메시지 브로커로 사용하기
- 레디스의 pub/sub에서 모든 데이터는 한 번 채널 전체에 전파된 뒤 삭제되는 일회성의 특징을 가지며, 메시지가 잘 전달됐는지 등의 정보는 보장하지 않는다.
- 완벽하게 메시지가 전달돼야 하는 상황에는 적합하지 않을 수 있지만 fire-and-forget 패턴이 필요한 간단한 알림(notification) 서비스에서는 유용하게 사용될 수 있다.
- 레디스의 list 자료구조는 메시징 큐로 사용하기에 알맞다.
- list의 데이터는 푸시와 팝이 가능하며 애플리케이션은 list에 데이터가 있는지 매번 확인할 필요없이 대기하다가 list에 새로운 데이터가 들어오면 읽어갈 수 있는 블로킹 기능을 사용할 수도 있다.
- 레디스 stream은 아파치 카프카 시스템에서 영감을 받아 만들어진 자료구조로, 데이터는 계속해서 추가되는 방식으로 저장된다(append-only).
- stream에 저장되는 메시지를 실시간으로 리스닝하며 소비할 수도 있으며, 저장돼 있는 데이터를 시간대별로 검색하는 것도 가능하다.
## 레디스의 pub/sub
- 한 번 전파된 데이터는 레디스에 저장되지 않으며, 단순히 메시지의 통로 역할만 한다.
- 만약 특정 구독자에 장애가 생겨 메시지를 받지 못했다 하더라도 그 사실을 알 수 없기 때문에 정합성이 중요한 데이터를 전달하기에는 적합하지 않을 수 있다.
### 메시지 publish하기
```shell

> PUBLISH hello world
(integer) 1
```
- hello라는 채널을 수신하고 있는 모든 서버들에 world라는 메시지가 전파된다.
- 메시지가 전파된 후에는 메시지를 수신한 구독자의 수가 반환 된다.
### 메시지 구독하기
```shell

> SUBSCRIBE eventi evnet2
Reading messages... (press Ctri-C to quit)
1) "subscribe"
2) "eventi"
3) (integer) 1
1) "subscribe"
2) "evnet?"
3) (integer) 2
```
- event1과 event2 채널을 동시에 구독하기 시작한다.
- 구독자가 수행할 수 있는 커맨드는 SUBSCRIBE, SSUBSCRIBE, SUNSUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE, PUNSUBSCRIBE, PING, RESET, QUIT이다.
```shell

> PSUBSCRIBE mail-*
Reading messages... (press Ctri- to quit)
1) "psubscribe"
2) "mail-*"
3) (integer) 1
```
- PSUBSCRIBE mail-*라는 커맨드를 사용하면 mail-track, mail-album 등 앞부분이 mail-로 시작하는 모든 채널에 전파된 메시지를 모두 수신할 수 있다.
### 클러스터 구조에서의 pub/sub
- 레디스 클러스터에서 pub/sub을 사용할 때, 메시지를 발행하면 해당 메시지는 클러스터에 속한 모든 노드에 자동으로 전달된다.
- 클러스터는 주로 대규모 서비스에서 데이터를 분산해서 저장하고 처리하기 위해 도입됐으며, 그렇기 때문에 레디스 클러스터 내에서 pub/sub을 사용할 때 메시지가 모든 레디스 노드에 복제되는 방식은 클러스터 환경의 핵심 목표와는 부합하지 않는다.
### sharded pub/sub
- sharded pub/sub 환경에서 각 채널은 슬롯에 매핑된다.
- 클러스터에서 키가 슬롯에 할당되는 것과 동일한 방식으로 채널이 할당되며, 같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파한다.
- SPUBLISH 커맨드로 발행된 메시지는 모든 노드에 전파되지 않으며, 노드의 복제본에만 전달된다.
```shell

10.0.0.1:6379> SPUBLISH apple a
-> Redirected to slot [7092] located at 10.0.0.2:6379
(integer) 1
10.0.0.2:6379>
```
```shell

10.0.0.1:6379> SUBSCRIBE apple
Reading messages... (press Ctri-C to quit)
-> Redirected to slot [7092] located at 10.0.0.2:6379
Reading messages... (press Ctri-C to quit)
1) "ssubscribe"
2) "apple"
3) (integer) 1
1) "smessage"
2) "apple"
3) "a"
```
## 레디스의 list를 메시징 큐로 사용하기
- 레디스에는 큐의 tail과 head에서 데이터를 넣고 뺄 수 있는 LPUSH, LPOP, RPUSH, RPOP 커맨드가 존재하기 때문에 애플리케이션 특성에 맞는 메시징 큐를 직접 구현할 수 있다는 장점이 있다.
### list의 EX 기능
- 인스타그램, 트위터, 페이스북, 유튜브와 같은 SNS에는 각 유저별 타임라인이 존재하며 각자의 타임라인에 자신이 팔로우한 계정의 게시물, 혹은 자신과 관련 있는 게시물 등이 표시된다.
- 트위터는 각 유저의 타임라인 캐시 데이터를 레디스에서 list 자료구조로 관리한다.
- 유저 A가 새로운 트윗을 작성하면 그 데이터는 A를 팔로우하는 유저의 타임라인 캐시에 저장된다.
- A가 쓴 트윗의 데이터는 유저 B와 C의 타임라인 캐시 list에 새로운 아이템으로 추가된다.
- RPUSHX는 데이터를 저장하고자 하는 list가 이미 존재할 때에만 아이템을 추가하는 커맨드다.
- 이 커맨드를 이용하면 이미 캐시된(이미 키가 존재하는) 타임라인에만 데이터를 추가할 수 있다.
```shell

> RPUSHX Timelinecache:userB data3
(integer) 26
> RPUSHX Timelinecache:userC data3
(integer) 5
> RPUSHX Timelinecache:userD data3
(integer) 0
```
### list의 블로킹 기능
- 이벤트 루프는 이벤트 큐에 새 이벤트가 있는지 체크하며, 새로운 이벤트가 없을 경우 정해진 시간(폴링 인터벌Polling interval) 동안 대기한 뒤 다시 이벤트 큐에 데이터가 있는지 확인하는 과정을 반복한다.
- 이벤트 큐에 이벤트가 들어왔을 수 있지만, 폴링 인터벌 시간 동안은 대기한 뒤 다시 확인하는 과정을 거치기 때문에 이벤트를 즉시 처리할 수 없다는 단점이 있다.
- 이때 list의 블로킹 기능을 사용하면 이와 같은 불필요함을 줄일 수 있다.
- BLPOP을 사용해 데이터를 요청했을 때 list에 데이터가 있으면 즉시 반환한다.
- 데이터가 없을 경우에는 list에 데이터가 들어올 때까지 기다린 후에 들어온 값을 반환하거나, 클라이언트가 설정한 타임아웃시간만큼 대기한 후에 nil 값을 반환한다.
```shell

> BRPOP queue:a 5
1) "queue:a"
2) "data"
```
- BRPOP은 RPOP과는 다르게 2개의 데이터를 반환한다. 첫 번째는 팝된 리스트의 키 값을 반환하고, 두 번째에 반환된 데이터의 값을 반환한다.
- 이렇게 설계된 이유는 동시에 여러 개의 리스트에서 대기할 수 있게 하기 위해서다.
```shell

> BRPOP queue:a queue:b queue:c timeout 1000
1) "queue:b"
2) "DATA"
(19.895)
```
### list를 이용한 원형 큐
- 특정 아이템을 계속해서 반복 접근해야 하는 클라이언트, 혹은 여러 개의 클라이언트가 병렬적으로 같은 아이템에 접근해야 하는 클라이언트에서는 원형 큐(Circular queue)를 이용해 아이템을 처리하고 싶을 수 있다.
```shell

> LPUSH clist A
(integer) 1

> LPUSH clist B
(integer) 2

> LPUSH clist C
(integer) 3

> LRANGE clist 0 -1
1) "C"
2) "B"
3) "A"

> RPOPLPUSH clist clist
"A"

> LRANGE clist 0 -1
1) "A"
2) "C"
3) "B"
```
## Stream
### 레디스의 Stream과 아파치 카프카
- 데이터를 계속해서 추가하는 방식으로 저장되는(append-only) 자료구조다.
- 백엔드 개발자들은 stream을 대량의 데이터를 효율적으로 처리하는 플랫폼으로 활용할 수 있다.
- 데이터 엔지니어들은 stream을 여러 생산자가 생성한 데이터를 다양한 소비자가 처리할 수 있게 지원하는 데이터 저장소 및 중간 큐잉 시스템으로 사용할 수 있다.
### 스트림이란?
- 스트림이란 연속적인 데이터의 흐름, 일정한 데이터 조각의 연속을 의미한다.
- 파일 하나는 유한하지만 이를 읽어올 때 애플리케이션은 단어 단위, 또는 줄 단위로 데이터를 잘게 쪼개서 처리하기 때문에 프로그램은 바이트 스트림을 처리하는 것이라고 생각할 수 있다.
- 끝이 정해지지 않고 계속되는 불규칙한 데이터를 연속으로 반복 처리할 때 이 또한 스트림 처리를 한다고 부를 수 있다.
- 채팅 앱에서 사용자는 아무때나 채팅을 보낼 수 있으며, 메신저 서버는 사람들이 계속 채팅하는 동안 끝없이 데이터를 처리할 수 있어야 한다.
- 따라서 이 상황에서 서버는 JSON 스트림을 처리하는 것이라고 볼 수 있다.
- 위 두 가지 예제는 애플리케이션 외부에서 인풋을 받아오는 스트리밍 처리 예제이지만, 애플리케이션 내부에서 서버 간 데이터의 이동이 필요할 수도 있다.
- 여러 프로듀서가 만든 이벤트는 다양한 프로세스를 거쳐 다양한 소비자에 의해 처리될 수 있다.
- 웹 서버 이벤트는 데이터베이스에 저장되거나 캐시에 저장될 수 있으며, 결제 이벤트는 데이터베이스뿐만 아니라 이메일이나 푸시 등의 서비스로 보내져 사용자가 알림을 받을 수 있도록 처리할 수 있다.
### 데이터의 저장
#### 메시지의 저장과 식별
- 레디스에서는 하나의 stream 자료구조가 하나의 stream을 의미한다.
- 레디스의 string, hash, sorted set 등 다른 자료구조와 마찬가지로 stream 형태의 자료구조가 존재하며, 각 자료 구조가 하나의 키에 연결되는 것과 마찬가지로 stream 또한 하나의 키에 연결된 자료구조다.
- 레디스 stream에서 각 메시지는 시간과 관련된 유니크한 ID를 가지며, 이 값은 중복되지 않는다.
```text
<millisecondsTime>-<sequenceNumber>
```
- 밀리세컨드 파트는 실제 stream에 아이템이 저장될 시점의 레디스 노드 로컬 시간이다.
- 시퀀스 파트는 동일한 밀리세컨드 시간에 여러 아이템이 저장될 수 있으므로, 같은 밀리세컨드에 저장된 데이터의 순서를 의미한다.
#### 스트림 생성과 데이터 입력
- 레디스에서는 따로 Stream을 생성하는 과정은 필요하지 않으며, XADD 커맨드를 이용해 새로운 이름의 stream에 데이터를 저장하면 데이터의 저장과 동시에 stream 자료구조가 생성된다.
```shell

> XADD Email * subject "first" body "hello?"
"1659114481311-0"
```
- \* 필드는 저장되는 데이터의 ID를 의미하며, 이 값을 *로 입력할 경우 레디스에서 자동생성되는 타임스탬프 ID를 사용하겠다는 것을 의미한다.
- XADD 커맨드를 사용했을 때 반환되는 값이 바로 저장되는 데이터의 ID이다.
- 메시지는 키 값 쌍으로 저장되며, 위의 예제에서 subject라는 키에는 first 값을, body라는 키에는 hello?라는 값이 저장된다.
```shell

> XADD Push * userid 1000 ttl 3 body Hey
"1659114966798-0"

> XADD Email * subject "second" body "hi?"
"1659114481311-0"
```
- 첫 번째 커맨드를 수행하면 Push라는 stream 자료구조가 새로 생성되며, 해당 stream에 ID가 1659114966798-0인 메시지가 신규로 저장된다.
- 두 번째 커맨드를 수행했을 때에는 이미 Email stream이 존재하기 때문에 ID가 1659114481311-0인 새로운 메시지가 Email stream에 저장된다.
- 만약 자동으로 생성되는 ID가 아니라 서비스에서 기존에 사용하던 ID를 이용해 메시지를 구분하고 싶을 수 있다. 이 때에는 ID를 입력하는 필드에 *가 아니라 직접 ID 값을 지정하면 된다.
```shell

> XADD mystream 0-1 "hello" "world"
0-1

> XADD mystream 0-2 "hi" "redis"
0-2
```
