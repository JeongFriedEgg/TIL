# CH.8 복제
- 복제 : 마스터 노드의 데이터를 복제본 노드로 실시간 복사하는 기능이다. 마스터 노드의 서버에 장애가 생겨 데이터가 유실된다 해도 복제본 노드에서 데이터를 확인할 수 있다.
- 자동 페일오버 : 마스터 노드에서 발생한 장애를 감지해 레디스로 들어오는 클라이언트 연결을 자동으로 복제본 노드로 리디렉션하는 기능이다. 이를 통해 수동으로 레디스의 엔드포인트를 변경할 필요가 없어 빠른 장애 조치가 가능하다.
## 레디스에서의 복제 구조
- 복제본 노드를 추가하는 이유
  - 애플리케이션이 실행중인 하드웨어는 언제든지 고장날 수 있으므로, 서비스를 안정적으로 운영하기 위해서는 마스터 데이터베이스가 다운됐을 때 대신 사용할 여분의 복제본이 필요하다.
  - 대규모 서비스에서 복제본은 트래픽을 감소시키는 역할을 수행할 수 있다. 실시간으로 마스터 노드에 접근해 데이터를 가져가는 서비스가 많을 때, 일부 트래픽이 복제본을 바라보게 한다면 부하분산을 통해 마스터 노드로의 트래픽을 줄일 수 있게 된다.
  - 운영중인 마스터 노드에서 매번 데이터의 백업을 받는 것은 부담스러운 작업이다. 백업을 복제본에서 수행하면 백업작업이 서비스에 미치는 영향도를 최소화할 수 있다.
- 레디스 버전 2.6 이상부터 복제본 노드는 기본으로 읽기 전용으로 동작하기 때문에 데이터를 읽는 커맨드만 수행할 수 있다.
- 모든 데이터의 입력은 마스터 노드에서 이뤄지는게 일반적이며, 복제본은 마스터에서 변경된 데이터를 그대로 받아온다.
### 복제 구조 구성하기
```shell

REPLICAOF <master-ip> <master-port>
```
- `REPLICAOF` 커맨드를 입력해 마스터 노드의 정보를 입력하면 복제 연결이 시작된다.
- 레디스에서 마스터에는 여러 개의 복제본이 연결될 수 있으며, 복제본 노드에 새로운 복제본을 추가하는 것도 가능하다.
### 패스워드 설정
- `requirepass` 옵션을 이용해 패스워드를 설정할 수 있다.
- 복제본 노드는 `masterpass` 옵션에 마스터의 `requirepass`에 설정된 패스워드 값을 입력해야 한다.
- 실행중인 복제본 인스턴스에서는 다음과 같은 방법으로 옵션을 수정한 뒤 설정파일을 다시 작성할 수도 있다.
```shell

> CONFIG SET masterauth mypassword
OK
> CONFIG REWRITE
OK
```
## 복제 메커니즘
- 버전 7 이전
  1. `REPLICAOF` 커맨드로 복제 연결을 시도한다.
  2. 마스터 노드에서는 fork로 자식 프로세스를 새로 만든 뒤 RDB 스냅숏을 생성한다.
  3. (2)번 과정 동안 마스터 노드에서 수행된 모든 데이터셋 변경 작업은 레디스 프로토콜(RESP) 형태로 마스터의 복제버퍼에 저장된다.
  4. RDB 파일이 생성 완료되면 파일은 복제본 노드로 복사된다.
  5. 복제본에 저장됐던 모든 내용을 모두 삭제한 뒤 RDB 파일을 이용해 데이터를 로딩한다.
  6. 복제 과정 동안 버퍼링됐던 복제버퍼의 데이터를 복제본으로 전달해 수행시킨다.
- 복제 과정에서 복제 속도는 디스크 I/O 처리량에 영향을 받는다.
- 마스터에서 RDB 파일을 저장하는 시간, 복제본에서 RDB 파일을 읽어오는 과정 모두 디스크 I/O 속도에 영향을 받기 때문이다.
- 만약 로컬 디스크에 RDB 파일을 쓰는 것이 아니라 NAS와 같은 원격 디스크를 사용한다면 디스크 I/O 속도는 더욱 느려질 수 있다.
- 버전 7 이후
  1. `REPLICAOF` 커맨드로 복제 연결을 시도한다.
  2. 마스터 노드는 소켓 통신을 이용해 복제본 노드에 바로 연결하며, RDB 파일은 생성됨과 동시에 점진적으로 복제본의 소켓에 전송된다.
  3. (2)의 과정 동안 마스터 노드에서 수행된 모든 데이터셋 변경 작업은 레디스 프로토콜(RESP) 형태로 마스터의 복제 버퍼에 저장된다.
  4. 소켓에서 읽어온 RDB 파일을 복제본의 디스크에 저장한다.
  5. 복제본에 저장된 모든 데이터를 모두 삭제한 뒤 RDB 파일 내용을 메모리에 로당한다.
  6. 복제 버퍼의 데이터를 복제본으로 전달해 수행시킨다.
- 복제본 노드는 마스터에서 가져온 데이터를 불러오기 전에 자신의 데이터를 모두 삭제하는 과정을 거쳐야 하는데, 이때 소켓 통신으로 받아온 RDB 데이터가 정상적인지를 미리 확인할 수 없기 때문에 모두 삭제하기 전 자신의 디스크에 데이터를 저장하는 과정을 선행함으로 데이터의 안정성을 확보할 수 있다.
- 디스크의 I/O가 느리고 네트워크가 빠른 경우 디스크를 사용하지 않는 복제 방식을 사용하는 것이 더 빠르게 복제 연결을 완료할 수 있는 방법이다.
- 기존에 디스크를 사용하는 복제를 사용했을 경우 RDB 파일이 생성되는 도중 다른 노드에서 복제 연결요청이 들어오면 이 연결은 큐에 저장되며 기존 RDB 파일의 저장이 완료되면 여러 복제본이 한 번에 복제연결을 시작할 수 있었다.
- 하지만 디스크를 사용하지 않는 방식에서 이미 하나의 복제본으로 복제연결이 시작된 경우에는 복제과정이 끝나기 전까지 다른 복제본과의 연결은 수행될 수 없으며, 다른 복제본들은 하나의 복제연결이 끝날때까지 큐에서 대기해야 한다.
- 이를 방지하기 위해 `repl-diskless-sync-delay` 옵션을 사용할 수 있다.
```shell

repl-diskless-sync-delay 5
```
- 새로운 복제 연결이 들어오면 기본 5초를 기다린 뒤 복제연결을 시작한다는 의미다.
- 이 기간 내에 또다른 복제연결이 들어오면 마스터는 여러 복제본으로 소켓 통신을 연결해 한 번에 여러개의 복제본에 RDB 파일을 전송할 수 있다.
- 보통 네트워크가 유실돼 재동기화를 요청할 경우 마스터에는 한 번에 여러개의 복제본에서 복제연결이 들어오는 것이 일반적이기 때문에 이 옵션을 활성화하는 것이 좋다.
### 비동기 방식으로 동작하는 복제 연결
- 마스터에서 복제본으로의 데이터 전달은 비동기 방식(asynchronous)으로 동작한다.
- 마스터에서 데이터를 입력하는 커맨드가 수행되면 레디스는 마스터 노드에서 커맨드를 처리한 이후 클라이언트에 OK 응답을 보낸다.
- 이후로 레디스 마스터 노드가 비정상 종료된 경우 이 데이터는 복제본 노드에 전달되지 않은 상태이기 때문에 유실될 가능성이 존재한다.
- 하지만 실제로 데이터가 복제본에 전달되는 속도는 굉장히 빠르기 때문에 이런 데이터의 유실이 빈번하게 발생되진 않는다.
### 복제 ID
- 모든 레디스 인스턴스는 복제 ID(replication ID)를 가지고 있다.
- 복제 ID는 오프셋과 쌍으로 존재한다.
- 레디스 내부의 데이터가 수정되는 모든 커맨드를 수행할 때마다 오프셋이 증가한다.
- 복제 연결을 시작하면 복제본의 replication id는 마스터의 replication id로 변경되며, 오프셋은 복제본에서 마지막으로 수행된 마스터의 오프셋을 의미한다.
- 현재 마스터 노드의 오프셋은 807, 복제본 노드의 오프셋은 801인 것으로 보아 현재 복제본은 마스터와 정확하게 일치하지 않으며, 802~807까지의 커맨드를 수행했을 때 마스터와 정확히 일치됨을 알 수 있다.
### 부분 재동기화
- 복제연결이 끊길 때마다 마스터에서 RDB 파일을 새로 내려 복제본에 전달하는 과정을 거친다면 네트워크가 불안정한 상황에서 복제기능을 사용하는 레디스의 성능은 급격하게 나빠질 것이다.
- 이를 방지하기 위해 레디스는 부분 재동기화(partial resynchronization)기능을 사용해 안정적으로 복제연결을 유지한다.
- 마스터는 커넥션 유실을 대비해 백로그 버퍼라는 메모리 공간에 복제본에 전달한 커맨드 데이터들을 저장해둔다.
- 하나의 복제그룹에서 replication id와 오프셋을 이용하면 복제본이 마스터의 어느 시점까지의 데이터를 가지고 있는지 파악할 수 있다. 
- 만약 복제 연결이 잠시 끊긴 뒤 재연결되면 복제본은 PSYNC 커맨드를 호출해 자신의 replication id와 오프셋을 마스터에 전달한다.
- 만약 오프셋 901~915의 내용이 마스터의 백로그에 저장돼 있다면 마스터는 RDB 파일을 새로 저장할 필요없이 백로그에 저장된 내용을 복제본에 전달함으로써 부분 재동기화를 진행할 수 있다.
- 하지만 마스터의 백로그 버퍼에 원하는 데이터가 남아있지 않거나, 복제본이 보낸 replication ID가 현재의 마스터와 일치하지 않다면 전체 재동기화(full resync)를 시도한다.
- 복제 백로그 크기는 `repl-back1og-size` 파라미터로 설정할 수 있으며, 기본값은 1MB이다.
- 복제연결이 끊겼을 때 백로그 크기가 클수록 복제본이 부분 재동기화를 수행할 수 있는 시간이 길어진다.
- 백로그는 1개 이상의 복제본이 연결된 경우에만 할당되며, `repl-backlog-ttl`만큼의 시간이 경과하면 메모리에서 백로그 공간을 삭제한다.
### Secondary 복제 ID
- 한 개의 복제본 그룹 내의 모든 레디스 노드는 동일한 복제 ID를 갖는다.
- A 노드에 장애가 발생해 복제가 끊어지고, 복제본 B가 새로운 노드로 승격되는 상황을 생각해보자.
- 마스터 노드와의 복제가 끊어짐과 동시에 복제본은 새로운 복제 ID를 갖게 된다.
- 노드 B가 기존의 복제 ID인 aaaaa를 유지하며 마스터로 동작하다가 장애가 해결된 뒤 기존 마스터 노드였던 A와 다시 연결된다면 두 노드는 동일한 복제 ID, 동일한 오프셋이 동일한 데이터셋을 갖는다는 사실을 위반할 수 있기 때문이다.
- 노드 B는 새로운 마스터로 승격됨과 동시에 새로운 복제 ID인 bbbbb 를 갖게 됐으며 기존의 복제 ID는 master_replid2에 저장된다.
- 기존 A의 복제본이었던 노드 C는 B에 연결됐으며, B의 복제 ID인 bbbbb를 복제 ID로 갖게 된다.
- C도 기존에 A 노드에 연결돼 있었기 때문에 master_repl1d2에는 A의 복제 ID인 aaaaa를 가지고 있다.
- 노드 C가 B에 복제 연결이 될 때, 두 노드의 master_replid2가 같기 때문에 C노드는 B노드에 부분 재동기화(partial resynchronization)를 시도한다.
- 노드 B와 C 모두 기존 A노드의 복제본으로 동일한 데이터셋을 가지고 있었기 때문에 노드B의 백로그가 재동기화를 하기 위한 데이터를 갖고 있는 경우라면 부분 재동기화만으로 노드 C가 B에 연결될 수 있다.
- 레디스가 2개의 복제 ID를 갖는 이유는 마스터로 승격되는 복제본 때문이며, 같은 복제그룹 내에서 페일오버 이후 승격된 새로운 마스터에 연결된 복제본은 전체 재동기화를 수행할 필요가 없을 수 있다.
### 읽기 전용 모드로 동작하는 복제본 노드
- 복제본에 직접 데이터를 쓸 수 있다 하더라도 복제본에 쓰는 내용은 오직 로컬에서만 유지되며, 해당 노드에 복제 연결된 다른 복제본으로는 전파되지 않는다.
- 마스터 노드 A에 연결된 B의 `replica-read-only` 설정은 꺼져 있으며, 클라이언트가 직접 B에 연결돼 데이터를 조작한다 하더라도, B에 복제 연결돼 있는 복제본 C는 항상 마스터 노드인 A와 동일한 데이터셋을 가진다.
- B에서 변경된 데이터는 C에 전달되지 않는다.
### 유효하지 않은 복제본 데이터
- 복제구조에서 유효하지 않은(stale) 데이터란 복제본의 데이터와 마스터의 데이터가 정확하게 일치하지 않는 경우의 데이터를 의미한다.
- 레디스에서 복제본이 마스터와 연결이 끊어진 상태, 혹은 복제연결이 시작된 뒤 아직 완료되지 않았을 경우에 복제본의 데이터가 유효하지 않다고 판단할 수 있다. 
- 복제본의 데이터가 유효하지 않다고 판단될 때 복제본의 동작 방식은 `replica-serve-stale-data` 파라미터를 이용해 제어할 수 있다.
- 기본값은 yes로, 복제본의 데이터가 유효하지 않다고 판단될 때에도 클라이언트로부터 들어오는 모든 읽기 요청에 데이터를 반환한다.
### 백업을 사용하지 않는 경우에서의 데이터 복제
- 레디스에서 복제를 사용하는 경우 마스터와 복제본에서 백업기능을 사용하는 것이 좋다.
- 만약 이 기능을 사용하지 않으려면 재부팅 후 레디스가 자동으로 재시작되지 않도록 설정할 것을 권장한다.
- 장애 상황
  1. 백업 기능을 사용하지 않는 마스터와 복제본 노드가 존재한다.
  2. 마스터 노드가 장애로 인해 종료됐지만, 레디스 프로세스를 자동 재시작하는 시스템에 의해 노드가 재부팅된다. 이때 메모리의 내용은 초기화된다.
  3. 복제본 노드에는 데이터가 존재하지만, 마스터 노드로의 복제연결을 시도한다.
  4. 마스터에서 복제본으로 빈 데이터셋을 전달한다.
- 만약 백업을 사용했다면 2번 상황에서 레디스가 재부팅될 때 백업파일을 자동으로 읽어오기 때문에 데이터가 복원되며, 복원된 내용이 복제본으로 전달된다. 
- 자동 재시작 기능을 사용하지 않았다면 복제본 노드에는 데이터가 존재하기 때문에 애플리케이션 연결설정을 마스터에서 복제본 노드로 변경해 데이터를 계속 사용할 수 있다.
- 혹은 복제본 노드에서 데이터를 새로 백업받아 마스터 노드에 전달한 뒤 마스터 노드를 시작시키면 복제본 노드에 저장된 내용으로 데이터가 복원될 수 있다.