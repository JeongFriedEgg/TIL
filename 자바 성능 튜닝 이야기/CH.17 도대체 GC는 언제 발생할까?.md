# CH.17 도대체 GC는 언제 발생할까?
## GC란?
- Garbage Collection는 말 그대로 쓰레기를 정리하는 작업이다.
- 자바에서 쓰레기는 객체이다. 하나의 객체는 메모리를 점유하고, 필요하지 않으면 메모리에서 해제되어야 한다.
```java
public String makeQuery(String code) {
    String queryPre = "Select * from table_a where a='";
    String queryPost = "' order by c";
    return queryPre + code + queryPost;
}
```
- makeQuery() 메서드를 호출한 후 수행이 완료되면 queryPre 객체와 queryPost 객체는 더이상 필요가 없는 객체, 즉 쓰레기가 된다고 했다.
- 이 쓰레기 객체를 효과적으로 처리하는 작업을 GC라고 한다.
## 자바의 Runtime data area는 이렇게 구성된다
- Runtime Data Areas
  - PC 레지스터
  - JVM 스택
  - 힙(Heap)
  - 메서드 영역
  - 런타임 상수(constant) 풀
  - 네이티브 메서드 스택
- 이 영역 중에서 GC가 발생하는 부분은 힙 영역이다.
### Heap 메모리
- 클래스 인스턴스, 배열이 이 메모리에 쌓인다.
- 이 메모리는 '공유(shared) 메모리'라고도 불리우며 여러 스레드에서 공유하는 데이터들이 저장되는 메모리다.
### Non-heap 메모리
- 자바의 내부처리를 위해서 필요한 영역이다. 주된 영역이 바로 메서드 영역이다.
  - 메서드 영역: 메서드 영역은 모든 JVM 스레드에서 공유한다. 이 영역에 저장되는 데이터들은 다음과 같다.
    - 런타임 상수 풀: 자바의 클래스 파일에는 constant_pool이라는 정보가 포함되어 있다. 이 constant_pool에 대한 정보를 실행시에 참조하기 위한 영역이다.
    - 필드 정보에는 메서드 데이터, 메서드와 생성자코드가 있다.
  - JVM 스택: 스레드가 시작할 때 JVM 스택이 생성된다. 이 스택에는 메서드가 호출되는 정보인 프레임(frame)이 저장된다. 그리고, 지역변수와 임시결과, 메서드수행과 리턴에 관련된 정보들도 포함된다.
  - 네이티브 메서드 스택: 자바 코드가 아닌 다른 언어로 된(보통은 C로 된) 코드들 이 실행하게 될 때의 스택정보를 관리한다.
  - PC 레지스터: 자바의 스레드들은 각자의 pc(Program Counter) 레지스터를 갖는다. 네이티브한 코드를 제외한 모든 자바 코드들이 수행될 때 JVM의 인스트럭션 주소를 pc 레지스터에 보관한다.
## GC의 원리
- 가비지 콜렉터(Garbage Collector) 역할
  - 메모리 할당
  - 사용 중인 메모리 인식
  - 사용하지 않는 메모리 인식
<br/><br/>
- 간략하게 표시된 자바의 메모리 영역

||Young 영역||Old 영역|
|---|---|---|---|
|Eden|Survivor1|Survivor2|메모리 영역|

- 메모리에 객체가 생성되면, Eden 영역에 객체가 지정된다.
- Eden 영역에 데이터가 꽉 차면, 이 영역에 있던 객체가 어디론가 옮겨지거나 삭제되어야 한다.
- 이 때 옮겨가는 위치가 Survivor 영역이다.
- 위의 그림에서는 구분을 하기 위해서 1과 2로 나눈 것뿐이며, 두 개의 Survivor 영역사이에 우선순위가 있는 것은 아니다.
- 이 두개의 영역중 한 영역은 반드시 비어 있어야 한다.
- 그 비어있는 영역에 Eden 영역에 있던 객체 중 GC 후에 살아남아있는 객체들이 이동한다.
- 할당된 Survivor 영역이 차면, GC가 되면서 Eden 영역에 있는 개체와 꽉찬 Survivor 영역에 있는 객체가 비어있는 Survivor 영역으로 이동한다.
- 이러한 작업을 반복하면서, Survivor 1과 2를 왔다갔다하던 객체들은 Old 영역으로 이동한다.
- Young 영역에서 Old 영역으로 넘어가는 객체 중 Survivor 영역을 거치지 않고 바로 Old 영역으로 이동하는 객체가 있을 수 있다. 객체의 크기가 아주 큰 경우이다.
## GC의 종류
- GC 타입
  - 마이너GC; Young 영역에서 발생하는 GC
  - 메이저GC: Old 영역이나 Perm 영역에서 발생하는 GC
- GC가 발생하거나 객체가 각 영역에서 다른 영역으로 이동할 때 애플리케이션의 병목이 발생하면서 성능에 영향을 주게 된다.
- 그래서 핫 스팟(Hot Spot) JVM에서는 스레드 로컬 할당 버퍼라는 것을 사용한다.
- 이를 통하여 각 스레드별 메모리 버퍼를 사용하면 다른 스레드에 영향을 주지 않는 메모리 할당작업이 가능해진다.
## 5가지 GC 방식
### 시리얼 콜렉터
- Young 영역과 Old 영역이 시리얼하게(연속적으로) 처리되며 하나의 CPU를 사용한다.
- Sun에서는 이 처리를 수행할 때를 Stop-the-world라고 표현한다.
- 콜렉션이 수행될 때 애플리케이션 수행이 정지된다.
1. 살아있는 객체들은 Eden 영역에 있다.
2. Eden 영역이 꽉차게 되면 To Survivor 영역(비어 있는 영역)으로 살아있는 객체가 이동한다. From Survivor 영역에 있는 살아있는 객체는 To Survivor 영역으로 이동한다.
3. To Survivor 영역이 꽉 찼을 경우, Eden 영역이나 From Survivor 영역에 남아있는 객체들은 Old 영역으로 이동한다.
- Old 영역이나 Perm 영역에 있는 객체들은 Mark-sweep-compact 콜렉션 알고리즘을 따른다.
- 콜렉션 알고리즘 수행
  - 1️⃣ Old 영역으로 이동된 객체들 중 살아 있는 객체를 식별한다(표시 단계).
  - 2️⃣ Old 영역의 객체들을 훑는 작업을 수행하여 쓰레기 객체를 식별한다(스윕 단계).
  - 3️⃣ 필요없는 객체들을 지우고 살아있는 객체들을 한 곳으로 모은다(컴팩션 단계).
### 병렬 콜렉터
- 스루풋 콜렉터(throughput collector)로도 알려진 방식이다.
- 이 방식의 목표는 다른 CPU가 대기 상태로 남아있는 것을 최소화하는 것이다.
- Young 영역에서의 콜렉션을 병렬(paralle)로 처리한다.
- 많은 CPU를 사용하기 때문에 GC의 부하를 줄이고 애플리케이션의 처리량을 중가시킬 수 있다.
- Old 영역의 GC는 시리얼 콜렉터와 마찬가지로 Mark-sweep-compact 콜렉션 알고리즘을 사용한다.
### 병렬 콤팩팅 콜렉터
- 병렬 콜렉터와 다른 점은 Old 영역 GC에서 새로운 알고리즘을 사용한다는 것이다.
- Young 영역에 대한 GC는 병렬 콜렉터와 동일하지만, Old 영역의 GC는 다음의 3단계를 거친다.
  - 표시 단계: 살아있는 객체를 식별하여 표시해 놓는 단계.
  - 종합 단계: 이전에 GC를 수행하여 컴팩션된 영역에 살아있는 객체의 위치를 조사하는 단계.
  - 컴팩션 단계: 컴팩션을 수행하는 단계. 수행 이후에는 컴팩션된 영역과 비어있는 영역으로 나뉜다.
- 병렬 콜렉터와 동일하게 이 방식도 여러 CPU를 사용하는 서버에 적합하다.
### CMS 콜렉터
- 로우 레이턴시 콜렉터(ow-latency collector)로도 알려져 있으며, 힙 메모리 영역의 크기가 클 때 적합하다.
- Old 영역의 GC
  - 초기 표시 단계: 매우 짧은 대기시간으로 살아있는 객체를 찾는 단계.
  - 컨커런트 표시 단계: 서버수행과 동시에 살아있는 객체에 표시를 해놓는 단계.
  - 재표시(remark) 단계: 컨커런트 표시 단계에서 표시하는 동안 변경된 객체에 대해서 다시 표시하는 단계.
  - 컨커런트 스윕 단계: 표시되어 있는 쓰레기를 정리하는 단계.
- CMS 콜렉터 방식은 2개 이상의 프로세서를 사용하는 서버에 적당하다.
- 가장 적당한 대상으로는 웹 서버가 있다.
- CMS 콜렉터는 추가적인 옵션으로 점진적 방식을 지원한다. 이 방식은 Young 영역의 GC를 더 잘게 쪼개어 서버의 대기시간을 줄일 수 있다.
- CPU가 많지 않고 시스템의 대기시간이 짧아야 할 때 사용하면 좋다.
### G1 콜렉터
- G1은 Young 영역과 old 영역이 물리적으로 나뉘어 있지 않고, 각 구역의 크기는 모두 동일하다.
- 앞서 살펴본 콜렉터들은 모두 Young과 Old 영역의 주소가 물리적으로 Linear하게 나열되지만, G1은 그렇지 않다.
- 여기서 구역의 개수는 약 2000개 정도라고 한다. 
- 이 바둑판 모양의 구역이 각각 Eden, Survivor, Old 영역의 역할을 변경해 가면서 하고, Humongous라는 영역도 포함된다.
- G1의 Young GC
  - 몇 개의 구역을 선정하여 Young 영역으로 지정한다.
  - 이 Linear하지 않은 구역에 객체가 생성되면서 데이터가 쌓인다.
  - Young 영역으로 할당된 구역에 데이터가 꽉 차면, GC를 수행한다.
  - GC를 수행하면서 살아있는 객체들만 Survivor 구역으로 이동시킨다.
- 이렇게 살아남은 객체들이 이동된 구역은 새로운 Survivor 영역이 된다.
- 몇 번의 aging 작업을 통해서(Survivor 영역에 있는 객체가 몇 번의 Young GC 후에도 살아 있으면), Old 영역으로 승격된다.
- G1의 Old 영역 GC
  - 초기 표시(Initial Mark) 단계 (STW): Old 영역에 있는 객체에서 Survivor 영역의 객체를 참조하고 있는 객체들을 표시한다.
  - 기본 구역 스캔(Root region scanning) 단계 : Old 영역 참조를 위해서 Survivor 영역을 훑는다. 참고로 이 작업은 Young GC가 발생하기 전에 수행된다.
  - 컨커런트 표시 단계 : 전체 힙 영역에 살아있는 객체를 찾는다. 만약 이때 Young GC가 발생하면 잠시 멈춘다.
  - 재 표시(Remark) 단계 (STV): 힙에 있는 살아있는 객체들의 표시작업을 완료한다. 이 때 snapshot-at-the-beginning (SATB)라는 알고리즘을 사용하며, 이는 CMS GC에서 사용하는 방식보다 빠르다.
  - 청소 (cleaning) 단계 (STV): 살아있는 객체와 비어있는 구역을 식별하고, 필요없는 개체들을 지운다. 그리고 나서 비어있는 구역을 초기화한다.
  - 복사 단계 (STW): 살아있는 객체들을 비어있는 구역으로 모은다.
## 강제로 GC시키기
- 사용하지 말 것!!