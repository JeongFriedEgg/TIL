# CH.16 JVM은 도대체 어떻게 구동될까?
## HotSpot VM은 어떻게 구성되어 있을까?
- JIT 컴파일러는 프로그램의 성능에 영향을 주는 지점에 대해서 지속적으로 분석한다.
- HotSpot은 자바 1.3 버전부터 기본 VM으로 사용되어 왔기 때문에, 지금 운영되고 있는 대부분의 시스템들은 모두 HotSpot 기반의 VM이라고 생각하면 된다.
- HotSpot VM 주요 컴포넌트
  - VM(Virtual Machine) 런타임
  - JIT(Just In Time) 컴파일러
  - 메모리 관리자
- 'HotSpot VM 런타임'에 'GC 방식'과 'JIT 컴파일러'를 끼워맞춰 사용할 수 있다.
- VM 런타임'은 JIT 컴파일러용 API와 가비지 컬렉터용 API를 제공한다.
## JTT Optimizer라는게 도대체 뭘까?
- 컴파일이라는 작업은 상위 레벨의 언어로 만들어진 기계에 의존적인 코드로 변환하는 것을 말한다.
- 자바는 javac라는 컴파일러를 사용한다.
- 이 컴파일러는 소스코드를 바이트코드로 된 class라는 파일로 변환해준다.
- 그렇기 때문에 JVM은 항상 바이트코드로 시작하며, 동적으로 기계에 의존적인 코드로 변환한다. 
- JIT는 애플리케이션에서 각각의 메서드를 컴파일할 만큼 시간적 여유가 많지 않다.
- 그러므로, 모든 코드는 초기에 인터프리터에 의해서 시작되고, 해당코드가 충분히 많이 사용될 경우에 컴파일할 대상이 된다.
- HotSpot VM에서 이 작업은 각 메서드에 있는 카운터를 통해서 통제되며, 메서드에는 두 개의 카운터가 존재한다.
  - 수행 카운터(invocation counter): 메서드를 시작할 때마다 증가
  - 백에지 카운터(backedge counter): 높은 바이트코드 인덱스에서 낮은 인덱스로 컨트롤 흐름이 변경될 때마다 중가
- 백에지 카운터는 메서드가 루프가 존재하는지를 확인할 때 사용되며, 수행 카운터보다 컴파일 우선순위가 높다.
- 컴파일이 요청되면 컴파일 대상목록의 큐에 쌓이고, 하나 이상의 컴파일러 스레드가 이 큐를 모니터링한다.
- 만약 컴파일러 스레드가 바쁘지 않을 때는 큐에서 대상을 빼내서 컴파일을 시작한다.
- 보통 인터프리터는 컴파일이 종료되기를 기다리지 않는 대신, 수행 카운터를 리셋하고 인터프리터에서 메서드 수행을 계속한다.
- 컴파일이 종료되면, 컴파일된 코드와 메서드가 연결되어 그 이후부터는 메서드가 호출되면 컴파일된 코드를 사용하게 된다.
## JRockit의 JIT 컴파일 및 최적화 절차
- JVM은 각 OS에서 작동할 수 있도록 자바코드를 입력 값(정확하게는 바이트 코드)으로 받아 각종 변환을 거친 후 해당 칩의 아키텍처에서 잘 돌아가는 기계어 코드로 변환되어 수행되는 구조로 되어있다.
- JRockit 최적화 단계
  - JRockit runs JIT compilation
    - 자바 애플리케이션을 실행하면 기본적으로는 1번 단계인 JIT 컴파일을 거친 후 실행이 된다.
    - 이 단계를 거친 후 메서드가 수행되면, 그 다음부터는 컴파일된 코드를 호출하기 때문에 처리 성능이 빨라진다.
    - 애플리케이션이 시작하는 동안 몇천 개의 새로운 메서드가 수행되며 이로인해 다른 JVM보다 JRockit JVM이 더 느릴수도 있다.
    - 이 작업으로 인해 JIT가 메서드를 수행하고 컴파일하는 작업은 오버헤드가 되지만, JIT가 없으면 JVM은 계속 느린상태로 지속될 것이다.
    - 다시 말해서, JIT를 사용하면 시작할 때의 성능은 느리겠지만, 지속적으로 수행할 때는 더 빠른 처리가 가능하다.
    - 따라서, 모든 메서드를 컴파일하고 최적화하는 작업은 JVM 시작시간을 느리게 만들기 때문에 시작할 때는 모든 메서드를 최적화하지는 않는다.
  - JRockit monitors threads
    - JRockit에는 'Sampler thread'라는 스레드가 존재하며 주기적으로 애플리케이션의 스레드를 점검한다.
    - 이 스레드는 어떤 스레드가 동작중인지 여부와 수행내역을 관리한다.
    - 이 정보들을 통해서 어떤 메서드가 많이 사용되는지를 확인하여 최적화 대상을 찾는다.
  - JRockit JVM Runs Optimization
    - 'sampler thread'가 식별한 대상을 최적화한다.
    - 이 작업은 백그라운드에서 진행되며 수행중인 애플리케이션에 영향을 주지는 않는다.
```java
class A {
    B b;

    public void foo() {
        y = b.get();
        //중간 생략
        z = b - get();
        sum = y + z;
    }

    class B {
        int value;
        final int get() {
            return value;
        }
    }
}
```
- foo()라는 메서드를 보면 y와 2 변수에 b.ger()이라는 메서드를 호출하고, 그 결과를 더한다.
- 여기서 중복호출이 된다는 것을 알 수 있다. 게다가 B 클래스의 get() 메서드는 value 값만을 리턴하는 아주 단순한 코드다.
- 이 코드를 JRockit JIT 컴파일러에서는 다음과 같이 최적화한다.
```java
class A {
    в b;

    public void foo() {
        y = b.value;
        //중간 생략
        sum = y + y;
    }
}
```
## IBM JVM의 JTT 컴파일 및 최적화 절차
- JIT 컴파일 방식
  - 인라이닝(inlining)
    - 메서드가 단순할 때 적용되는 방식이며, 호출된 메서드가 단순할 경우 그 내용이 호출한 메서드의 코드에 포함해 버린다.
  - 지역 최적화(Local optimizations)
    - 작은 단위의 코드를 분석하고 개선하는 작업을 수행한다.
  - 조건 구문 최적화(Control flow optimizations)
    - 메서드 내의 조건구문을 최적화하고, 효율성을 위해서 코드의 수행경로를 변경한다.
  - 글로벌 최적화(Global optimizations)
    - 메서드 전체를 최적화하는 방식이다. 컴파일 시간이 많이 소요된다는 단점이 있지만, 성능 개선이 많이될 수 있다는 장점이 있다.
  - 네이티브 코드 최적화(Native code generation)
    - 이 방식은 플랫폼 아키텍처에 의존적이다. 아키텍처에 따라서 최적화를 다르게 처리하는 것을 말한다.
- 컴파일된 코드는 '코드 캐시(Code cache)'라고 하는 JVM 프로세스 영역에 저장된다.
- 결과적으로 JVM 프로세스는 JVM 수행파일과 컴파일된 JIT 코드의 집합으로 구분된다.
## JVM이 시작할 때의 절차는 이렇다
- 1️⃣ java 명령어 줄에 있는 옵션 파싱 : 일부 명령은 자바 실행 프로그램에서 적절한 JIT 컴파일러를 선택하는 등의 작업을 하기 위해서 사용하고, 다른 명령들은 HotSpot VM에 전달된다.
- 2️⃣ 자바 힙 크기할당 및 JIT 컴파일러 타입 지정 : 메모리 크기나 JIT 컴파일러 종류가 명시적으로 지정되지 않은 경우에 자바 실행 프로그램이 시스템의 상황에 맞게 선정한다.
- 3️⃣ CLASSPATH와 LD_LIBRARY_PATH 같은 환경변수를 지정한다.
- 4️⃣ 자바의 Main 클래스가 지정되지 않았으면, Jar 파일의 manifest 파일에서 Main 클래스를 확인한다.
- 5️⃣ JNI의 표준 API인 JNICreateJavaVM를 사용하여 새로 생성한 non-primordial이라는 스레드에서 HotSpot VM을 생성한다.
- 6️⃣ HotSpot VM이 생성되고 초기화되면, Main 클래스가 로딩된 런처에서는 main 메서드의 속성 정보를 읽는다.
- 7️⃣ CallStaticVoidMethod는 네이티브 인터페이스를 불러 HotSpot VM에 있는 main 메서드가 수행된다.
- 5️⃣에 있는 자바의 가상머신(VM)을 생성하는 JNI CreateJavaVM 단계
- 1️⃣ JNI_CreateJavaVM는 동시에 두개의 스레드에서 호출할 수 없고, 오직 하나의 HotSpot VM 인스턴스가 프로세스 내에서 생성될 수 있도록 보장된다. HotSpot VM이 정적인 데이터구조를 생성하기 때문에 다시 초기화는 불가능하기 때문에, 오직 하나의 HotSpot VM이 프로세스에서 생성될 수 있다.
- 2️⃣ JNI 버전이 호환성이 있는지 점검하고, GC 로깅을 위한 준비도 완료된다.
- 3️⃣ os 모듈들이 초기화된다. 예를 들면 랜덤 번호 생성기, PID 할당 등이 여기에 속한다.
- 4️⃣ 커맨드 라인 변수와 속성들이 JNILCreateJava VM 변수에 전달되고, 나중에 사용하기 위해서 파싱한 후 보관한다.
- 5️⃣ 표준 자바 시스템 속성(properties)이 초기화된다.
- 6️⃣ 동기화, 메모리, safepoint 페이지와 같은 모듈들이 초기화된다.
- 7️⃣ libzip, libhpi, libjava, libthread와 같은 라이브러리들이 로드된다.
- 8️⃣ 시그널 처리기가 초기화 및 설정된다.
- 9️⃣ 스레드 라이브러리가 초기화된다.
- 🔟 출력(output) 스트림 로거가 초기화된다.
- 1️⃣1️⃣ JVM을 모니터링하기 위한 에이전트 라이브러리가 설정되어 있으면 초기화 및 시작된다.
- 1️⃣2️⃣ 스레드 처리를 위해서 필요한 스레드 상태와 스레드 로컬 저장소가 초기화된다.
- 1️⃣3️⃣ HotSpot VM의 '글로벌 데이터'들이 초기화된다. 글로벌 데이터에는 이벤트 로그(event log), OS 동기화, 성능 통계 메모리(perfMemory), 메모리 할당자 (chunkPool)들이 있다.
- 1️⃣4️⃣ HotSpot VM에서 스레드를 생성할 수 있는 상태가 된다. main 스레드가 생성되고, 현재 OS 스레드에 붙는다.
- 1️⃣5️⃣ 자바 레벨의 동기화가 초기화 및 활성화된다.
- 1️⃣6️⃣ 부트 클래스로더, 코드 캐시, 인터프리터, JIT 컴파일러, JNI, 시스템 dictionary, '글로벌 데이터' 구조의 집합인 universe 등이 초기화된다.
- 1️⃣7️⃣ 스레드 목록에 자바 main 스레드가 추가되고, universe의 상태를 점검한다. HotSpot VM의 중요한 기능을 하는 HotSpot VMThread가 생성된다. 이 시점에 HotSpot VM의 현재상태를 JVMTI에 전달한다.
- 1️⃣8️⃣ java.lang 패키지에 있는 String, System, Thread, ThreadGroup, Class 클래스와 java.lang의 하위 패키지에 있는 Method, Finalizer 클래스 등이 로딩되고 초기화된다.
- 1️⃣9️⃣ HotSpot VM의 시그널 핸들러 스레드가 시작되고, JIT 컴파일러가 초기화되며, HotSpot의 컴파일 브로커 스레드가 시작된다. 그리고, HotSpot VM과 관련된 각종 스레드들이 시작한다. 이때부터 HotSpot VM의 전체기능이 동작한다.
- 2️⃣0️⃣ JNIEnv가 시작되며, HotSpot VM을 시작한 호출자에게 새로운 JNI 요청을 처리할 상황이 되었다고 전달해준다.
## JVM이 종료될 때의 절차는 이렇다
- JVM이 시작할 때 오류가 있어 시작을 중지할 때나, JVM에 심각한 에러가 있어서 중지할 필요가 있을 때는 DestroyJava VM이라는 메서드를 HotSpot 런처에서 호출한다.
- HotSpot VM의 종료
- 1️⃣ HotSpot VM이 작동중인 상황에서는 단 하나의 데몬이 아닌 스레드 (nondaemon thread)가 수행될 때까지 대기한다.
- 2️⃣ java.lang 패키지에 있는 Shutdown 클래스의 shutdown() 메서드가 수행된다. 이 메서드가 수행되면 자바 레벨의 shutdown hook이 수행되고, finalization-on-exit이라는 값이 true일 경우에 자바객체 finalizer를 수행한다.
- 3️⃣ HotSpot VM 레벨의 shutdown hook을 수행함으로써 HotSpot VM의 종료를 준비한다. 이 작업은 JVM_OnExir0메서드를 통해서 지정된다. 그리고, HotSpot VM의 profiler, stat sampler, watcher, garbage collector 스레드를 종료시킨다. 이 작업들이 종료되면 JVMTI를 비활성화하며, Signal 스레드를 종료시킨다.
- 4️⃣ HotSpot의 Java Thread:exit() 메서드를 호출하여 JNI 처리 블록을 해제한다. 그리고, guard pages, 스레드 목록에 있는 스레드들을 삭제한다. 이 순간부터는 HotSpot VM 에서는 자바코드를 실행하지 못한다.
- 5️⃣ HoSpot VM 스레드를 종료한다. 이 작업을 수행하면 HotSpot VM에 남아있는 HotSpot VM 스레드들을 safepoint로 옮기고, JIT 컴파일러 스레드들을 중지시킨다.
- 6️⃣ JNI, Hotspot VM, JVMT barrier에 있는 추적(tracing) 기능을 종료시킨다.
- 7️⃣ 네이티브 스레드에서 수행하고 있는 스레드들을 위해서 HotSpot의 vm exited" 값을 설정한다.
- 8️⃣ 현재 스레드를 삭제한다.
- 9️⃣ 입출력 스트림을 삭제하고, PerfMemory 리소스 연결을 해제한다.
- 🔟 JVM 종료를 호출한 호출자로 복귀한다.
## 클래스로딩 절차도 알고 싶어요? 
- 1️⃣ 주어진 클래스의 이름으로 클래스 패스에 있는 바이너리로 된 자바 클래스를 찾는다.
- 2️⃣ 자바 클래스를 정의한다. 
- 3️⃣ 해당 클래스를 나타내는 java.lang 패키지의 Class 클래스의 객체를 생성한다. 
- 4️⃣ 링크 작업이 수행된다. 이 단계에서 static 필드를 생성 및 초기화하고, 메서드 테이블을 할당한다.
- 5️⃣ 클래스의 초기화가 진행되며, 클래스의 static 블록과 static 필드가 가장 먼저 초기화 된다. 해당 클래스가 초기화되기 전에 부모 클래스의 초기화가 먼저 이루어진다.
### 부트스트랩(Bootstrap) 클래스로더
- Hotspot VM은 부트스트랩 클래스로더를 구현한다.
- 부트스트랩 클래스로더는 HotSpot VM의 BOOTCLASSPATH에서 클래스들을 로드한다.
### HotSpot의 클래스 메타데이터(Metadata)
- HotSpot VM 내에서 클래스를 로딩하면 클래스에 대한 instanceKlass와 arrayKlass라는 내부적인 형식을 VM의 Perm 영역에 생성한다.
- instanceKlass는 클래스의 정보를 포함하는 java.lang.Class 클래스의 인스턴스를 말한다.
- HotSpot VM은 내부 데이터구조인 klassOop라는 것을 사용하여 내부적으로 instanceklass에 접근한다.
- 여기서 Oop라는 것은 ordinary object pointer의 약자다.
### 내부 클래스 로딩 데이터의 관리
- HotSpot VM은 클래스 로딩을 추적하기 위해서 다음의 3개의 해시 테이블을 관리한다.
  - SystemDictionary
    - 로드된 클래스를 포함하며, 클래스이름 및 클래스로더를 키를 갖고 그 값으로 klassOop를 갖고 있다.
    - SystemDictionary는 클래스이름과 초기화한 로더의 정보, 클래스이름과 정의한 로더의 정보도 포함한다.
  - PlaceholderTable
    - 현재 로딩된 클래스들에 대한 정보를 관리한다.
    - 이 테이블은 ClassCircularity Error를 체크할 때 사용하며, 다중 스레드에서 클래스를 로딩하는 클래스 로더에서도 사용된다.
  - LoaderConstraintTable
    - 타입 체크시의 제약사항을 추정하는 용도로 사용된다.
## 예외는 JVM에서 어떻게 처리될까?
- 일반적인 예외 처리 경우는
  - 예외를 발생한 메서드에서 잡을 경우
  - 호출한 메서드에 의해서 잡힐 경우
- 예외는, 던져진 바이트 코드에 의해서 초기화 될 수 있으며, VM 내부호출의 결과로 넘어올수도 있고, JNI 호출로 부터 넘어올수도 있고, 자바 호출로부터 넘어올수도 있다.
- VM이 예외가 던져졌다는 것을 알아차렸을 때, 해당 예외를 처리하는 가장 가까운 핸들러를 찾기 위해서 HotSpot VM 런타임 시스템이 수행된다.
- 핸들러를 찾기 위해서는 다음의 3개의 정보가 사용된다.
  - 현재 메서드
  - 현재 바이트 코드
  - 예외 객체
- 적당한 핸들러를 찾으면, HotSpot VM 수행상태가 변경되며, HotSpot VM은 핸들러로 이동하고 자바 코드수행은 계속된다.