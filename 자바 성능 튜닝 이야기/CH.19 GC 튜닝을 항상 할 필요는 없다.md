# CH.19 GC 튜닝을 항상 할 필요는 없다.
## GC 튜닝을 꼭 해야 할까?
- GC 튜닝이 필요 없는 경우
  - -Xms 옵션과 - Xmx 옵션으로 메모리 크기를 지정했다.
  - -server 옵션이 포함되어 있다.
- 시스템의 로그에는 타임아웃 관련 로그가 남아있지 않아야 한다.
  - DB 작업과 관련된 타임아웃
  - 다른 서버와의 통신시 타임아웃
- 타임아웃 로그가 존재하고 있다는 것은 그 시스템을 사용하는 사용자 중 대다수나 일부는 정상적인 응답을 받지 못했다는 말이다.
- 대부분 서로 다른 서버간에 통신문제나 원격서버의 성능이 느려서 타임아웃이 발생할 수도 있지만, 그 이유가 GC 때문일 수도 있다.
- JVM의 메모리 크기도 지정하지 않았고, Timeout이 지속적으로 발생하고 있다면 시스템에서 GC튜닝을 하는 것이 좋다.
- GC 튜닝은 가장 마지막에 하는 작업이다.
- GC 튜닝을 왜 하는지 근본적인 이유를 생각해 보자. Java에서 생성된 객체는 가비지 컬렉터(Garbage Collector)가 처리해서 지운다.
- 생성된 객체가 많으면 많을수록 가비지 컬렉터가 처리해야 하는 대상도 많아지고, GC를 수행하는 횟수도 증가한다.
- 운영하고 만드는 시스템이 GC를 적게 하도록 하려면 객체생성을 줄이는 작업을 먼저 해야한다.
- String 대신 StringBuilder나 StringBuffer를 사용하는 거나, 로그를 최대한 적게 쌓도록 하는 등 임시 메모리를 적게 사용하도록 하는 작업은 중요하다.
- 만약 애플리케이션 메모리 사용도 튜닝을 많이 해서 어느정도 만족할만한 상황이 되었다면, 본격적으로 GC튜닝을 시작하면 된다.
- GC 튜닝의 목적. Old 영역으로 넘어가는 객체의 수를 최소화하는 것과 Full GC의 실행 시간을 줄이는 것이다.
### Old 영역으로 넘어가는 객체의 수 최소화하기
- Old 영역의 GC는 New 영역의 GC에 비하여 상대적으로 시간이 오래 소요되기 때문에 Old 영역으로 이동하는 객체의 수를 줄이면 Full GC가 발생하는 빈도를 많이 줄일 수 있다.
- New 영역의 크기를 잘 조절함으로써 큰 효과를 볼 수는 있다.
### Full GC 시간 줄이기
- Full GC실행에 시간이 오래 소요되면(1초 이상) 연계된 여러 부분에서 타임아웃이 발생할 수 있다.
- 그렇다고 Full GC 실행시간을 줄이기 위해서 Old 영역의 크기를 줄이면 OutOMemoryError가 발생하거나 Full GC횟수가 늘어난다.
- 반대로 Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행시간이 늘어난다.
- Old 영역의 크기를 적절하게 '잘' 설정해야 한다.
## GC의 성능을 결정하는 옵션들
- GC 옵션은 '누가 이 옵션을 썼을 때 성능이 잘 나왔대. 우리도 이렇게 적용하자!'라고 생각하면 절대 안 된다.
- 왜냐하면, 서비스마다 생성되는 객체의 크기도 다르고 살아있는 기간도 다르기 때문이다.

| 구분 | 옵션 | 설명 |
| :--- | :--- | :--- |
| 힙(heap) 영역 크기 | -Xms | JVM 시작 시 힙 영역 크기 |
| | -Xmx | 최대 힙 영역 크기 |
| New 영역의 크기 | -XX:NewRatio | New영역과 Old영역의 비율 |
| | -XX:NewSize | New영역의 크기 |
| | -XX:SurvivorRatio | Eden영역과 Survivor영역의 비율 |
- 이 중에서 필자가 GC 튜닝을 할 때 자주 사용하는 옵션은 -Xms, -Xmx, -XX:NewRatio 옵션이다.
- -Xms과 -Xmx는 필수로 지정해야 하는 옵션이다.
- NewRatio 옵션을 어떻게 설정하느냐에 따라서 GC 성능에 많은 차이가 발생한다.
- GC의 성능에 많은 영향을 주는 또다른 옵션은 GC 방식이다.

| 구분 | 옵션                                             | 비고 |
| :--- |:-----------------------------------------------| :--- |
| Serial GC | -XX:+UseSerialGC                               | |
| Parallel GC | -XX:+UseParallelGC                             | |
| | -XX:ParallelGCThreads=value                    | |
| Parallel Compacting GC | -XX:+UseParallelOldGC                          | |
| CMS GC | -XX:+UseConcMarkSweepGC                        | |
| | -XX:+UseParNewGC                               | |
| | -XX:+CMSParallelRemarkEnabled                  | |
| | -XX:CMSInitiatingOccupancyFraction=value       | |
| | -XX:+UseCMSInitiatingOccupancyOnly             | |
| G1 | -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC  | JDK 6에서는 두 옵션을 반드시 같이 사용해야 함 |
- G1 GC를 제외하고는, 각 GC 방식의 첫 번째 줄에 있는 옵션을 지정하면 GC 방식이 변경된다.
## GC 튜닝의 절차 369
1. GC 상황 모니터링
   - GC 상황을 모니터링하며 현재 운영되는 시스템의 GC 상황을 확인해야 한다.
2. 모니터링 결과분석 후 GC튜닝여부 결정
   - 분석한 결과를 확인했는데 GC수행에 소요된 시간이 0.1~0.3초 밖에 안 된다면 굳이 GC 튜닝에 시간을 낭비할 필요는 없다. 하지만 GC수행시간이 1~3 초, 심지어 10초가 넘는 상황이라면 GC 튜닝을 진행해야 한다.
3. GC 방식/메모리 크기 지정
   - GC 방식을 선정하고 메모리의 크기를 지정한다. 서버가 여러 대이면 서버에 GC옵션을 서로 다르게 지정해서 GC옵션에 따른 차이를 확인하는 것이 중요하다.
4. 결과 분석
   - GC 옵션을 지정하고 적어도 24시간 이상 데이터를 수집한 후에 분석을 실시한다. 그 다음에 GC 방식/메모리 크기를 변경해 가면서 최적의 옵션을 찾아나간다.
5.  결과가 만족스러울 경우 전체서버에 반영 및 종료
## 1,2 단계: GC 상황 모니터링 및 결과 분석하기
- 운영 중인 WAS의 GC 상황을 확인하는 가장 좋은 방법은 jstat 명령어를 사용하는 것이다.
- GC 튜닝을 안 한 어떤 JVM의 상황
```text
$ jstat -gcutil 21719 1s

S0     S1     E      O      P      YGC    YGCT   FGC    FGCT   GCT
48.66  0.00   48.10  49.70  77.45  3428   172.623 3     59.050 231.673
48.66  0.00   48.10  49.70  77.45  3428   172.623 3     59.050 231.673
```
1. YGC와 YGCT의 값을 확인한다.
   - YGCT 값을 YGC로 나누면 0.050초(50ms)라는 값이 나온다. 즉, Young 영역에서 GC가 수행되는데 평균 50ms가 소요되었다는 말이다. 이 정도면 Young 영역의 GC는 신경쓰지 않아도 된다.
2. FGCT와 FGC의 값을 확인한다.
   - FGCT 값을 FGC로 나누면 19.68초리는 값이 나온다. 평균 19.68초가 소요되었다는 말이다. 세 번의 GC에서 모두 19.68초가 걸렸을 수도 있고, 두 번의 GC는 1초가 소요되고 한 번의 GC는 58초가 소요됐을 수도 있다. 그러나 어떤 경우이던 GC 튜닝이 필요한 경우라고 판단할 수 있다.
- 이렇게 GC의 상황을 jstat으로 간단하게 확인할 수도 있지만, - verbosegc 옵션으로 로그를 남겨 분석하는 것이 가장 좋다.
- GC가 수행되는 시간을 확인했을 때 결과가 다음의 조건에 모두 부합한다면 GC튜닝이 필요없다.
  - Minor GC의 처리 시간이 빠르다(50ms내외).
  - Minor GC 주기가 빈번하지 않다(10초 내외).
  - Full GC의 처리 시간이 빠르다(보통 1초 이내).
  - Full GC 주기가 빈번하지 않다(10분에 1회).
- 위에서 괄호안에 있는 값은 절댓값은 아니고 서비스의 상황에 따라 달라질 수 있는 값이다.
- Full GC처리속도가 0.9초가 나와도 만족하는 서비스가 있고, 그렇지 않은 서비스도 있기 때문이다.
- GC 상황을 확인할 때 Minor GC와 Full GC의 시간만 보면 안 된다는 점이다. GC가 수행되는 횟수도 확인해야 한다.
- 만약 New 영역의 크기가 너무 작게 잡혀있다면 Minor GC가 발생하는 빈도가 매우 높을 뿐만 아니라, Old 영역으로 넘어가는 객체의 개수도 증가하게 되어 Full GC 횟수도 중가한다.
## 3-1 단계: GC 방식 지정
- GC 방식은 Oracle JVM을 기준으로 총 5가지가 있다.
- 그중 Serial GC는 운영에서 사용하지 못한다.
- 그리고 JDK 7이 아니라면 이 GC를 제외해야 하므로 Parallel GC, Parallel Compacting GC, CMS GC의 3개 중에 하나를 선택해야 한다.
- 가장 좋은 방법은 3가지를 다 적용해 보는 것인데, 일반적으로 CMS GC는 다른 Parallel GC보다 작업 속도가 빠르다.
- 일반적인 CMS GC의 Full GC 처리시간은 빠르지만, Concurrent mode failure가 발생하면 다른 Parallel GC보다 느려진다.
### Concurrent mode failure에 대해서 좀 더 알아 보자.
- Parallel GC와 CMS GC의 가장 큰 차이점은 압축(Compaction)작업 여부이다.
- 압축 작업은 메모리 할당공간 사이에 사용하지 않는 빈 공간이 없도록 옮겨서 메모리 단편화를 제거하는 작업이다. 
- Parallel GC 방식에서는 Full GC가 수행될 때마다 압축 작업을 진행하기 때문에 시간이 많이 소요된다.
- 하지만, Full GC가 수행된 이후에는 메모리를 연속적으로 지정할 수 있어 메모리를 더 빠르게 할당할 수 있다.
- 반대로 CMS GC는 기본적으로 압축작업을 수행하지 않기 때문에 당연히 속도가 빠르다.
- 하지만, 압축작업을 수행하지 않으면 디스크 조각모음을 실행하기 전의 상태처럼 메모리에 빈 공간이 여기저기 생긴다.
- 그렇기 때문에 크기가 큰 객체가 들어갈 수 있는 공간이 없을수도 있다.
- 예를 들어, Old 영역에 남아있는 크기가 300MB인데도 10MB짜리 객체가 연속적으로 들어갈 공간이 없을 수 있다는 말이다.
- 그럴 때 Concurrent mode failure라는 경고가 발생하면서 압축작업을 수행한다.
- 그런데, CMS GC를 사용할 때는 압축시간이 다른 Parallel CC보다 더 오래 소요된다.
- 그래서 오히려 더 문제가 될 수 있다.
## 3-2 단계: 메모리 크기
- 여기서 말하는 메모리 크기는 JVM의 시작 크기(-Xms)와 최대 크기(-Xmx)를 말한다.
- 메모리 크기가 크면, GC 발생 횟수는 감소한다. GC 수행 시간은 길어진다.
- 메모리 크기가 작으면, GC 발생 횟수는 짧아진다. GC 수행 시간은 증가한다.
- 서버자원이 좋은 시스템이라서 메모리를 10GB로 설정해도 Full GC가 1초 이내에 끝난다면 10GB로 지정해도 된다.
- 하지만, 대부분의 서버는 메모리를 10GB 정도로 설정하면 Full GC 시간이 10~30초 정도 소요된다.
- GC 튜닝 이전에 현재 상황을 모니터링한 결과를 바탕으로 Full GC가 발생한 이후에 남아있는 메모리의 크기를 봐야 한다.
- 만약 Full GC 후에 남아있는 Old 영역의 메모리가 300MB 정도라면 300MB(기본 사용)+ 500MB(Old 영역용 최소) + 200MB(여유 메모리)를 감안하여 Old 영역만 1GB 정도로 지정하는 것이 좋다.
- 그래서 3대 정도의 운영서버가 있다면, 서버 한대는 1GB로, 다른 한대는 1.5 GB로, 또 다른 한대는 2GB 정도로 지정한 후 결과를 지켜본 다음 결정한다.
- 메모리 크기를 지정할 때 해야 하는 것이 한 가지 더 있다. 바로 NewRatio다. NewRatio는 New 영역과 Old 영역의 비율이다.
- -XX:NewRatio=1로 지정하면 (New 영역):(Old 영역)의 비율은 1:1이 된다.
- 만약 1GB라면 (New 영역):Old 영역)은 S00MB:S00MB가 된다.
- NewRatio가 2이면 (New 영역):(Old 영역)이 1:2가 된다.
- 즉, 값이 커지면 커질수록 Old 영역의 크기가 커지고 New 영역의 크기가 작아진다.
- GC 튜닝을 가장 빨리 진행하는 방법
  - 성능 테스트를 통해서 GC튜닝을 하면 빠른 시간에 결과를 얻을 수 있다.
  - 그런데 문제는 운영상황과 동일하게 부하를 줄 수 있는 환경을 구성해야하는 작업이 쉽지 않다는 점이다.
  - 그리고 부하를 주는 URL과 같은 요청비율도 운영과 동일해야 한다.
## 4단계: GC튜닝 결과 분석
- GC 옵션을 적용하고, -verbosegc 옵션을 지정한 다음에 tail 명령어로 로그가 제대로 쌓이고 있는지 확인해야 한다.
- 분석할 때 사항
  - Full GC 수행시간
  - Minor GC 수행시간
  - Full GC 수행간격
  - Minor GC 수행간격
  - 전체 Full GC 수행시간
  - 전체 Minor GC 수행시간
  - 전체 GC 수행시간
  - Full GC 수행횟수
  - Minor GC 수행횟수