# CH.24 애플리케이션에서 점검해야 할 대상들
## 패턴과 아키텍처는 잘 구성되어 있는가?
- 너무 많은 패턴을 사용하지 않았는가?
  - 어떤 시스템을 만들더라도 패턴은 애플리케이션을 구성할 때 반드시 적용해야 한다.
  - 하지만 너무 많은 패턴을 적용하면 유지보수성이 떨어지고, 문제가 발생했을 때 추적하기가 어려워진다.
- 데이터를 리턴할 때 TO(혹은 VO) 패턴을 사용하였는가? 아니면 Collection 관련 클래스를 사용하였는가?
  - 이러한 패턴을 적용하지 않거나 관련표준을 정하지 않고 개발을 할 경우 시스템의 응답 시간도 영향이 있겠지만, 유지 보수성이 떨어진다.
  - 게다가 HashMap으로 데이터를 주고 받으면, 소스를 완전히 뜯어보지 않는 이상 개발자만 어떤 키와 값이 들어있는지 알게 된다.
- 서비스 로케이터(Service Locator) 패턴은 적용이 되어 있는가?
  - 서비스 로케이터 패턴을 사용하면 애플리케이션에서 필요한 대상을 찾는 룩업(lookup) 작업을 할 때 소요되는 대기시간을 줄일 수 있다.
## 기본적인 애플리케이션 코딩은 잘 되어 있는가?
- 명명 규칙은 잘 지켰는가?
  - 그 클래스 이름을 보고 어떤 일을 하는 클래스인지 바로 인식이 가능한지를 확인해야 한다.
- 필요한 부분에 예외 처리는 되어 있는가?
  - 예외 처리를 제대로 하지 않으면 사용자는 아무런 응답을 받지 못하고, 여러분이 운영하는 시스템을 더 이상 사용하지 않을수도 있다.
  - 문제가 발생했을 때 원인을 밝히기 위해서 예외처리는 필수다.
- 예외 화면은 지정되어 있는가?
  - 만약 예외화면을 구성하지 않고 지정하지도 않는다면, 사용자는 여러분이 사용하는 서버의 종류가 어떤 것인지 알게 될 것이다.
  - 때에 따라서는 시스템에 어떤 클래스가 있는지도 확인할 수 있을 것이다.
- 예외 정보를 혹시 e.printStackTrace()로만 처리하고 있지 않은가?
  - e.printStackTrace() 메서드를 호출하면 서버에서 스택정보를 취합하여야 하기 때문에 서버에 많은 부하가 발생하게 된다.
  - 만약 여러분의 애플리케이션이 복잡하게 구성되어 있다면, 최대 100개의 스택정보가 프린트되기 위해서 서버에 부하를 줄 것이다.
  - 다른 로그와 섞여있는 스택정보 로그를 통해서 얼마나 문제를 해결할 수 있을까?
- System.gc() 메서드가 소스에 포함되어 있지 않은가?
- System.exit() 메서드가 소스에 포함되어 있지 않은가?
- 문자열을 계속 더하도록 코딩하지는 않았는가?
  - 루프를 수행하면서 문자열을 더할 경우에는 컴파일러도 어쩔 수가 없으니 반드시 필요에 따라서 StringBuffer나 StringBuilder 클래스를 선택하여 사용하기 바란다.
- StringBuffer나 StringBuilder 클래스도 제대로 사용했는가?
  - StringBuffer의 객체가 sb라고 했을 때, sb.append("aaa"+"bbb");라고 사용한다면 제대로 이해하지 못하고 사용하는 것이다.
- 무한루프가 작동할만한 코드는 없는가?
  - while(true)의 구문을 사용한다면, 해당루프는 언제 끝날지 아무도 보장할 수 없다.
  - 해당 구문안에서 조건을 만족시키지 못하고 무한루프를 돌게 된다면'이라는 가정을 할 필요가 없도록 코딩을 하자.
- static을 남발하지 않았는가?
- 필요한 부분에 synchronized 블록을 사용하였는가?
  - 필요없는 부분에 synchronized 블록을 사용하게 될 경우 성능저하를 발생시킬 수 있다.
- IO가 계속 발생하도록 개발되어 있지 않은가?
  - 가장 많이 실수하는 부분이 설정 파일을 매번 파일에서 읽도록 개발하는 것이다.
- 필요없는 로그는 다 제거했는가?
  - '로그 레벨이 DEBUG가 아니니 괜찮겠지.'하는 생각은 버려라.
- 디버그용 System.out.println은 다 제거했는가?
## 웹 관련 코딩은 잘 되어 있는가?
- JSP의 include는 동적으로 했는가? 아니면 정적으로 했는가?
  - JSP를 동적으로 include하면 서버에도 부하를 줄 뿐만 아니라 응답 시간에도 영향을 준다.
  - 꼭 필요한 부분에만 동적 include를 하기 바라며, 그렇지 않은 경우에는 정적 include의 사용을 권장한다.
- 자바 빈즈는 너무 많이 사용하지 않았나?
  - 하나의 화면에서 자바빈즈를 수십 개씩 사용하지 않는가?
  - 하나의 TO(Transfer Object)를 사용해서 처리할수도 있는 데이터라면, 여러 개의 자바 빈즈를 사용해서 응답 시간에 영향을 주는 일이 없도록 하자.
- 태그 라이브러리는 적절하게 사용했나?
- EJB는 적절하게 사용하였나?
- 이미지 서버를 사용할 수 있는 환경인가?
  - 이미지, 자바스크립트, CSS, 플래시 등 정적인 컨텐츠가 많고 사용자의 요청이 많은 경우에는 웹 서버 이외에 이미지 서버를 사용할 수 있다.
- 사용 중인 프레임워크는 검증되었는가?
## DB 관련 코딩은 잘 되어 있는가?
- 적절한 JDBC 드라이버를 사용하는가?
  - 되도록이면 가장 최신의 WAS 및 DB 벤더에서 추천하는 문제 없는 JDBC를 사용하기를 권장한다.
- DB Connection, Statement, ResultSet은 잘 닫았는가?
  - 반드시 finally 구문을 사용해서 Connection, Statement, Resultset을 명시적으로 닫아주기 바란다.
- DB Connection Pool은 잘 사용하고 있는가?
  - 관련되는 표준을 반드시 정하고, DB Connection Pool은 반드시 사용해야 DB의 리소스를 보다 효율적으로 사용할 수 있다.
- 자동 커밋 모드에 대한 고려는 하였는가?
  - 기본 커밋 모드는 자동 커밋으로 되어 있다. 하지만 조회성 프로그램도 자동커밋여부를 지정하게 되면, 약간의 응답시간저하가 발생하게 된다.
  - 반드시 필요하지 않은 경우에는 자동커밋을 하도록 하자.
- ResultSet.last() 메서드를 사용하였는가?
- PreparedStatements를 사용하였는가?
  - Statement를 사용하면 매번 쿼리를 수행할 때마다 SQL 쿼리를 컴파일하게 된다. 이 작업은 DB에 많은 부하를 준다.
  - 그러므로 쿼리 문장이 계속 동적으로 변경되어야 하는 경우를 제외한 대부분의 경우에는 PreparedStatements를 사용하기 바란다.
## 서버의 설정은 잘 되어 있는가?
- 자바 VM 관련 옵션들은 제대로 설정되어 있는가?
  - 64비트 기반의 시스템을 사용하면서 -d64 옵션을 사용하지 않는다면, 그냥 32비트로 시스템이 운영된다.
  - 클래스 패스(dass path)는 순차적으로 인식된다.
- 메모리는 몇 MB로 설정해 놓았는가?
  - 설정하지 않으면 서버는 기본 64MB로 시작한다는 사실을 반드시 기억하기 바란다.
- GC 설정은 어떻게 되어 있는가?
- 서버가 운영모드인지 개발 모드인지 확인하였는가?
  - 서버가 개발모드라면, WAS는 주기적으로 변경된 클래스가 있는지 확인할 것이다.
  - 이 작업은 서버에 많은 부하를 주게 된다. 서버가 주기적으로 느려진다면, 이 부분은 반드시 확인하자.
- WAS의 인스턴스가 몇 개 기동되고 있는가?
  - WAS에서 하나의 인스턴스당 적어도 한 개는 있어야 제대로 된 운영이 가능하다.
  - CPU는 4개인데, 인스턴스가 30개정도 있는 것은 아닌지 확인하기 바란다.
  - WAS의 CPU 개수가 적을 경우, 때에 따라서 인스턴스 개수를 중가시키면 서버의 처리량이 증가될 수 있다.
- JSP Precompile 옵션은 지정해 놓았는가?
  - 서버를 기동할 때 JSP를 미리 컴파일하도록 해 놓으면 사용자는 JSP가 수정이 되었는지 여부와 상관없이 일정한 응답속도를 느낄 것이다.
- DB Connection Pool 개수와 스레드 개수는 적절한가?
  - 스레드 개수가 DB Connection Pool의 수보다 절대로 적어서는 안 된다.
  - 스레드의 개수는 DB Connection Pool의 개수보다 보통 10개 정도 더 많이 설정한다.
- 세션 타임아웃 시간은 적절한가?
  - 세션을 더 이상 사용하지 않을 때 세션정보는 삭제되어야 한다.
- 검색서버가 있다면, 검색서버에 대한 설정 및 성능 테스트를 하였는가?
## 모니터링은 어떻게 하고 있는가?
- 웹 로그(Access log)는 남기고 있는가?
  - 애플리케이션의 사용량과 자주 사용하는 애플리케이션을 분석하기 위해서, 추후 용량산정의 기초자료가 되는 웹 로그는 반드시 남겨서 관리하자.
- verbosegc 옵션은 남기고 있는가?
  - 메모리의 크기를 지정하기 위해서나, GC 옵션을 변경하기 위해서라도 verbosegc 옵션은 매우 유용하게 활용될 것이다.
- 각종 로그 파일에 대한 규칙은 있는가?
  - 로그 파일이 그냥 몇 기가바이트씩 쌓이고 있지 않은가? 일별로 로그를 쌓도록 옵션을 지정하면, 특정 이슈가 발생한 날짜의 데이터를 분석하기에도 좋고 백업을 하기에도 편리하다.
- 서버의 시스템 사용률은 로그로 남기고 있는가?
  - WAS나 DB가 얼마나 사용을 하고 있는지 로그를 남겨야 한다.
- 모니터링 툴은 사용 중인가?
  - 만약 모니터링 툴을 구매할 여력이 안되고 서버가 많은 부하를 받고 있지 않는다면, JMX 기술을 사용하여 서버를 모니터링하는 것도 좋은 방법이다.
- 모니터링 툴에 대한 설정은 적절하게 되어 있는가?
  - 모든 메서드에 대해서 프로파일링을 하도록 지정을 하면 대부분의 툴이 성능에 많은 영향을 주게 된다.
  - 그러므로 꼭 필요한 내용만 모니터링이 되도록 설정을 잘 맞추어야 제대로 사용할 수 있다.
- 서버가 갑자기 코어덤프를 발생시키지 않는가?
  - 만약 서버가 지속적으로 코어 덤프를 발생시킨다면 적어도 다음의 내용을 점검해보기 바란다.
1. 10,000건 이상 조회하는 것이 있나 확인해야 한다. 한꺼번에 많은 양의 데이터를 처리하려면 많은 메모리가 필요한데, 이 때 코어덤프가 발생할 수 있다. 데이터를 처리하는데 필요한 메모리가 지정된 메모리 크기보다 클 수도 있기 때문이다.
2. 메모리 릭이 있는지 확인해야 한다. 메모리를 점유하고 해제하지 않는 로직이 있으면 서버를 매일 재기동해도 메모리는 점차적으로 부족해진다. 서버가 기동된 후 힙 덤프를 받아 놓은 뒤, 운영중과 운영후에 각각 덤프를 받아서 메모리 사용량의 추이를 확인해야 한다.
- 응답시간이 너무 느리지 않은가?
  - 웅답 시간이 느려지는 이유는 상상을 초월할 정도로 많다.
  - WAS단 이후에서 느린 것인지, 그 이전 단계인 네트워크나 웹 서버에서 느린지 확인해야 한다.
  - 만약 WAS에서 느리다면, 정확히 어느 부분에서 느린지 프로파일링을 해서 확인해 봐야 한다.